From adab1994c1bbc38744a4631c7d1df08f3439c471 Mon Sep 17 00:00:00 2001
From: Colin Watson <cjwatson@ubuntu.com>
Date: Tue, 15 Jan 2013 12:02:35 +0000
Subject: [PATCH 106/364] Remove nested functions from memory map iterators.

* grub-core/efiemu/mm.c (grub_efiemu_mmap_iterate): Add hook_data
argument, passed to hook.
* grub-core/kern/i386/coreboot/mmap.c
(grub_linuxbios_table_iterate): Likewise.
(grub_machine_mmap_iterate: iterate_linuxbios_table): Make static
instead of nested.
(grub_machine_mmap_iterate): Add hook_data argument.
* grub-core/kern/i386/multiboot_mmap.c (grub_machine_mmap_iterate):
Add hook_data argument, passed to hook.
* grub-core/kern/i386/pc/mmap.c (grub_machine_mmap_iterate):
Likewise.
* grub-core/kern/i386/qemu/mmap.c (grub_machine_mmap_iterate):
Likewise.
* grub-core/kern/ieee1275/mmap.c (grub_machine_mmap_iterate):
Likewise.
* grub-core/kern/mips/arc/init.c (grub_machine_mmap_iterate):
Likewise.
* grub-core/kern/mips/loongson/init.c (grub_machine_mmap_iterate):
Likewise.
* grub-core/kern/mips/qemu_mips/init.c (grub_machine_mmap_iterate):
Likewise.
* grub-core/mmap/efi/mmap.c (grub_efi_mmap_iterate): Likewise.
(grub_machine_mmap_iterate): Likewise.
* grub-core/mmap/mmap.c (grub_mmap_iterate): Likewise.
* include/grub/efiemu/efiemu.h (grub_efiemu_mmap_iterate): Update
prototype.
* include/grub/memory.h (grub_memory_hook_t): Add data argument.
Remove NESTED_FUNC_ATTR from here and from all users.
(grub_mmap_iterate): Update prototype.
(grub_efi_mmap_iterate): Update prototype.  Update all callers to
pass appropriate hook data.
(grub_machine_mmap_iterate): Likewise.

* grub-core/commands/acpi.c (grub_acpi_create_ebda: find_hook): Make
static instead of nested.
* grub-core/commands/lsmmap.c (grub_cmd_lsmmap: hook): Likewise.
Rename to ...
(lsmmap_hook): ... this.
* grub-core/efiemu/mm.c (grub_efiemu_mmap_init: bounds_hook):
Likewise.
(grub_efiemu_mmap_fill: fill_hook): Likewise.
* grub-core/kern/i386/coreboot/init.c (grub_machine_init:
heap_init): Likewise.
* grub-core/kern/i386/pc/init.c (grub_machine_init: hook): Likewise.
Rename to ...
(mmap_iterate_hook): ... this.
* grub-core/kern/ieee1275/init.c (grub_claim_heap: heap_init):
Likewise.
* grub-core/lib/ieee1275/relocator.c
(grub_relocator_firmware_get_max_events: count): Likewise.
(grub_relocator_firmware_fill_events: fill): Likewise.  Rename
to ...
(grub_relocator_firmware_fill_events_iter): ... this.
* grub-core/lib/relocator.c (grub_relocator_alloc_chunk_align:
hook): Likewise.  Rename to ...
(grub_relocator_alloc_chunk_align_iter): ... this.
* grub-core/loader/i386/bsd.c (generate_e820_mmap: hook): Likewise.
Rename to ...
(generate_e820_mmap_iter): ... this.
* grub-core/loader/i386/linux.c (find_mmap_size: hook): Likewise.
Rename to ...
(count_hook): ... this.
(grub_linux_boot: hook): Likewise.  Rename to ...
(grub_linux_boot_mmap_find): ... this.
(grub_linux_boot: hook_fill): Likewise.  Rename to ...
(grub_linux_boot_mmap_fill): ... this.
* grub-core/loader/i386/multiboot_mbi.c (grub_fill_multiboot_mmap:
hook): Likewise.  Rename to ...
(grub_fill_multiboot_mmap_iter): ... this.
* grub-core/loader/multiboot.c (grub_get_multiboot_mmap_count:
hook): Likewise.  Rename to ...
(count_hook): ... this.
* grub-core/loader/multiboot_mbi2.c (grub_fill_multiboot_mmap:
hook): Likewise.  Rename to ...
(grub_fill_multiboot_mmap_iter): ... this.
* grub-core/loader/powerpc/ieee1275/linux.c
(grub_linux_claimmap_iterate: alloc_mem): Likewise.
* grub-core/loader/sparc64/ieee1275/linux.c (alloc_phys: choose):
Likewise.  Rename to ...
(alloc_phys_choose): ... this.
(determine_phys_base: get_physbase): Likewise.
* grub-core/mmap/i386/mmap.c (grub_mmap_malign_and_register:
find_hook): Likewise.
* grub-core/mmap/i386/pc/mmap.c (preboot: fill_hook): Likewise.
(malloc_hook: count_hook): Likewise.
* grub-core/mmap/i386/uppermem.c (grub_mmap_get_lower: hook):
Likewise.  Rename to ...
(lower_hook): ... this.
(grub_mmap_get_upper: hook): Likewise.  Rename to ...
(upper_hook): ... this.
(grub_mmap_get_post64: hook): Likewise.  Rename to ...
(post64_hook): ... this.
* grub-core/mmap/mips/uppermem.c (grub_mmap_get_lower: hook):
Likewise.  Rename to ...
(lower_hook): ... this.
(grub_mmap_get_upper: hook): Likewise.  Rename to ...
(upper_hook): ... this.
* grub-core/mmap/mmap.c (grub_mmap_iterate: count_hook): Likewise.
(grub_mmap_iterate: fill_hook): Likewise.
(fill_mask): Pass addr and mask within a single struct.
(grub_cmd_badram: hook): Make static instead of nested.  Rename
to ...
(badram_iter): ... this.
(grub_cmd_cutmem: hook): Likewise.  Rename to ...
(cutmem_iter): ... this.
---
 ChangeLog                                 | 110 +++++++++
 grub-core/commands/acpi.c                 |  55 +++--
 grub-core/commands/lsmmap.c               |  31 ++-
 grub-core/efiemu/mm.c                     |  97 ++++----
 grub-core/kern/i386/coreboot/init.c       |  68 +++---
 grub-core/kern/i386/coreboot/mmap.c       |  66 +++--
 grub-core/kern/i386/multiboot_mmap.c      |   4 +-
 grub-core/kern/i386/pc/init.c             |  61 ++---
 grub-core/kern/i386/pc/mmap.c             |  14 +-
 grub-core/kern/i386/qemu/mmap.c           |  14 +-
 grub-core/kern/ieee1275/init.c            | 124 +++++-----
 grub-core/kern/ieee1275/mmap.c            |   4 +-
 grub-core/kern/mips/arc/init.c            |   4 +-
 grub-core/kern/mips/loongson/init.c       |   6 +-
 grub-core/kern/mips/qemu_mips/init.c      |   4 +-
 grub-core/lib/ieee1275/relocator.c        | 102 ++++----
 grub-core/lib/relocator.c                 | 143 ++++++-----
 grub-core/loader/i386/bsd.c               | 136 ++++++-----
 grub-core/loader/i386/linux.c             | 256 ++++++++++----------
 grub-core/loader/i386/multiboot_mbi.c     |  74 +++---
 grub-core/loader/multiboot.c              |  23 +-
 grub-core/loader/multiboot_mbi2.c         |  66 ++---
 grub-core/loader/powerpc/ieee1275/linux.c |  76 +++---
 grub-core/loader/sparc64/ieee1275/linux.c | 129 +++++-----
 grub-core/mmap/efi/mmap.c                 |  23 +-
 grub-core/mmap/i386/mmap.c                |  52 ++--
 grub-core/mmap/i386/pc/mmap.c             |  49 ++--
 grub-core/mmap/i386/uppermem.c            |  83 ++++---
 grub-core/mmap/mips/uppermem.c            |  58 ++---
 grub-core/mmap/mmap.c                     | 388 ++++++++++++++++--------------
 include/grub/efiemu/efiemu.h              |   2 +-
 include/grub/memory.h                     |  18 +-
 32 files changed, 1305 insertions(+), 1035 deletions(-)

diff --git a/ChangeLog b/ChangeLog
index 1c0e633..d07f235 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,113 @@
+2013-01-15  Colin Watson  <cjwatson@ubuntu.com>
+
+	Remove nested functions from memory map iterators.
+
+	* grub-core/efiemu/mm.c (grub_efiemu_mmap_iterate): Add hook_data
+	argument, passed to hook.
+	* grub-core/kern/i386/coreboot/mmap.c
+	(grub_linuxbios_table_iterate): Likewise.
+	(grub_machine_mmap_iterate: iterate_linuxbios_table): Make static
+	instead of nested.
+	(grub_machine_mmap_iterate): Add hook_data argument.
+	* grub-core/kern/i386/multiboot_mmap.c (grub_machine_mmap_iterate):
+	Add hook_data argument, passed to hook.
+	* grub-core/kern/i386/pc/mmap.c (grub_machine_mmap_iterate):
+	Likewise.
+	* grub-core/kern/i386/qemu/mmap.c (grub_machine_mmap_iterate):
+	Likewise.
+	* grub-core/kern/ieee1275/mmap.c (grub_machine_mmap_iterate):
+	Likewise.
+	* grub-core/kern/mips/arc/init.c (grub_machine_mmap_iterate):
+	Likewise.
+	* grub-core/kern/mips/loongson/init.c (grub_machine_mmap_iterate):
+	Likewise.
+	* grub-core/kern/mips/qemu_mips/init.c (grub_machine_mmap_iterate):
+	Likewise.
+	* grub-core/mmap/efi/mmap.c (grub_efi_mmap_iterate): Likewise.
+	(grub_machine_mmap_iterate): Likewise.
+	* grub-core/mmap/mmap.c (grub_mmap_iterate): Likewise.
+	* include/grub/efiemu/efiemu.h (grub_efiemu_mmap_iterate): Update
+	prototype.
+	* include/grub/memory.h (grub_memory_hook_t): Add data argument.
+	Remove NESTED_FUNC_ATTR from here and from all users.
+	(grub_mmap_iterate): Update prototype.
+	(grub_efi_mmap_iterate): Update prototype.  Update all callers to
+	pass appropriate hook data.
+	(grub_machine_mmap_iterate): Likewise.
+
+	* grub-core/commands/acpi.c (grub_acpi_create_ebda: find_hook): Make
+	static instead of nested.
+	* grub-core/commands/lsmmap.c (grub_cmd_lsmmap: hook): Likewise.
+	Rename to ...
+	(lsmmap_hook): ... this.
+	* grub-core/efiemu/mm.c (grub_efiemu_mmap_init: bounds_hook):
+	Likewise.
+	(grub_efiemu_mmap_fill: fill_hook): Likewise.
+	* grub-core/kern/i386/coreboot/init.c (grub_machine_init:
+	heap_init): Likewise.
+	* grub-core/kern/i386/pc/init.c (grub_machine_init: hook): Likewise.
+	Rename to ...
+	(mmap_iterate_hook): ... this.
+	* grub-core/kern/ieee1275/init.c (grub_claim_heap: heap_init):
+	Likewise.
+	* grub-core/lib/ieee1275/relocator.c
+	(grub_relocator_firmware_get_max_events: count): Likewise.
+	(grub_relocator_firmware_fill_events: fill): Likewise.  Rename
+	to ...
+	(grub_relocator_firmware_fill_events_iter): ... this.
+	* grub-core/lib/relocator.c (grub_relocator_alloc_chunk_align:
+	hook): Likewise.  Rename to ...
+	(grub_relocator_alloc_chunk_align_iter): ... this.
+	* grub-core/loader/i386/bsd.c (generate_e820_mmap: hook): Likewise.
+	Rename to ...
+	(generate_e820_mmap_iter): ... this.
+	* grub-core/loader/i386/linux.c (find_mmap_size: hook): Likewise.
+	Rename to ...
+	(count_hook): ... this.
+	(grub_linux_boot: hook): Likewise.  Rename to ...
+	(grub_linux_boot_mmap_find): ... this.
+	(grub_linux_boot: hook_fill): Likewise.  Rename to ...
+	(grub_linux_boot_mmap_fill): ... this.
+	* grub-core/loader/i386/multiboot_mbi.c (grub_fill_multiboot_mmap:
+	hook): Likewise.  Rename to ...
+	(grub_fill_multiboot_mmap_iter): ... this.
+	* grub-core/loader/multiboot.c (grub_get_multiboot_mmap_count:
+	hook): Likewise.  Rename to ...
+	(count_hook): ... this.
+	* grub-core/loader/multiboot_mbi2.c (grub_fill_multiboot_mmap:
+	hook): Likewise.  Rename to ...
+	(grub_fill_multiboot_mmap_iter): ... this.
+	* grub-core/loader/powerpc/ieee1275/linux.c
+	(grub_linux_claimmap_iterate: alloc_mem): Likewise.
+	* grub-core/loader/sparc64/ieee1275/linux.c (alloc_phys: choose):
+	Likewise.  Rename to ...
+	(alloc_phys_choose): ... this.
+	(determine_phys_base: get_physbase): Likewise.
+	* grub-core/mmap/i386/mmap.c (grub_mmap_malign_and_register:
+	find_hook): Likewise.
+	* grub-core/mmap/i386/pc/mmap.c (preboot: fill_hook): Likewise.
+	(malloc_hook: count_hook): Likewise.
+	* grub-core/mmap/i386/uppermem.c (grub_mmap_get_lower: hook):
+	Likewise.  Rename to ...
+	(lower_hook): ... this.
+	(grub_mmap_get_upper: hook): Likewise.  Rename to ...
+	(upper_hook): ... this.
+	(grub_mmap_get_post64: hook): Likewise.  Rename to ...
+	(post64_hook): ... this.
+	* grub-core/mmap/mips/uppermem.c (grub_mmap_get_lower: hook):
+	Likewise.  Rename to ...
+	(lower_hook): ... this.
+	(grub_mmap_get_upper: hook): Likewise.  Rename to ...
+	(upper_hook): ... this.
+	* grub-core/mmap/mmap.c (grub_mmap_iterate: count_hook): Likewise.
+	(grub_mmap_iterate: fill_hook): Likewise.
+	(fill_mask): Pass addr and mask within a single struct.
+	(grub_cmd_badram: hook): Make static instead of nested.  Rename
+	to ...
+	(badram_iter): ... this.
+	(grub_cmd_cutmem: hook): Likewise.  Rename to ...
+	(cutmem_iter): ... this.
+
 2013-01-13  Vladimir Serbinenko  <phcoder@gmail.com>
 
 	* grub-core/kern/emu/hostdisk.c (read_device_map): Explicitly
diff --git a/grub-core/commands/acpi.c b/grub-core/commands/acpi.c
index c6be5e1..891e392 100644
--- a/grub-core/commands/acpi.c
+++ b/grub-core/commands/acpi.c
@@ -142,49 +142,58 @@ iszero (grub_uint8_t *reg, int size)
 }
 
 #if defined (__i386__) || defined (__x86_64__)
+/* Context for grub_acpi_create_ebda.  */
+struct grub_acpi_create_ebda_ctx {
+  int ebda_len;
+  grub_uint64_t highestlow;
+};
+
+/* Helper for grub_acpi_create_ebda.  */
+static int
+find_hook (grub_uint64_t start, grub_uint64_t size, grub_memory_type_t type,
+	   void *data)
+{
+  struct grub_acpi_create_ebda_ctx *ctx = data;
+  grub_uint64_t end = start + size;
+  if (type != GRUB_MEMORY_AVAILABLE)
+    return 0;
+  if (end > 0x100000)
+    end = 0x100000;
+  if (end > start + ctx->ebda_len
+      && ctx->highestlow < ((end - ctx->ebda_len) & (~0xf)) )
+    ctx->highestlow = (end - ctx->ebda_len) & (~0xf);
+  return 0;
+}
+
 grub_err_t
 grub_acpi_create_ebda (void)
 {
+  struct grub_acpi_create_ebda_ctx ctx = {
+    .highestlow = 0
+  };
   int ebda_kb_len;
-  int ebda_len;
   int mmapregion = 0;
   grub_uint8_t *ebda, *v1inebda = 0, *v2inebda = 0;
-  grub_uint64_t highestlow = 0;
   grub_uint8_t *targetebda, *target;
   struct grub_acpi_rsdp_v10 *v1;
   struct grub_acpi_rsdp_v20 *v2;
-  auto int NESTED_FUNC_ATTR find_hook (grub_uint64_t, grub_uint64_t,
-				       grub_uint32_t);
-  int NESTED_FUNC_ATTR find_hook (grub_uint64_t start, grub_uint64_t size,
-				  grub_memory_type_t type)
-  {
-    grub_uint64_t end = start + size;
-    if (type != GRUB_MEMORY_AVAILABLE)
-      return 0;
-    if (end > 0x100000)
-      end = 0x100000;
-    if (end > start + ebda_len
-	&& highestlow < ((end - ebda_len) & (~0xf)) )
-      highestlow = (end - ebda_len) & (~0xf);
-    return 0;
-  }
 
   ebda = (grub_uint8_t *) (grub_addr_t) ((*((grub_uint16_t *)0x40e)) << 4);
   ebda_kb_len = *(grub_uint16_t *) ebda;
   if (! ebda || ebda_kb_len > 16)
     ebda_kb_len = 0;
-  ebda_len = (ebda_kb_len + 1) << 10;
+  ctx.ebda_len = (ebda_kb_len + 1) << 10;
 
   /* FIXME: use low-memory mm allocation once it's available. */
-  grub_mmap_iterate (find_hook);
-  targetebda = (grub_uint8_t *) (grub_addr_t) highestlow;
+  grub_mmap_iterate (find_hook, &ctx);
+  targetebda = (grub_uint8_t *) (grub_addr_t) ctx.highestlow;
   grub_dprintf ("acpi", "creating ebda @%llx\n",
-		(unsigned long long) highestlow);
-  if (! highestlow)
+		(unsigned long long) ctx.highestlow);
+  if (! ctx.highestlow)
     return grub_error (GRUB_ERR_OUT_OF_MEMORY,
 		       "couldn't find space for the new EBDA");
 
-  mmapregion = grub_mmap_register ((grub_addr_t) targetebda, ebda_len,
+  mmapregion = grub_mmap_register ((grub_addr_t) targetebda, ctx.ebda_len,
 				   GRUB_MEMORY_RESERVED);
   if (! mmapregion)
     return grub_errno;
diff --git a/grub-core/commands/lsmmap.c b/grub-core/commands/lsmmap.c
index bd32c33..8e7f2a5 100644
--- a/grub-core/commands/lsmmap.c
+++ b/grub-core/commands/lsmmap.c
@@ -21,6 +21,7 @@
 #include <grub/command.h>
 #include <grub/i18n.h>
 #include <grub/memory.h>
+#include <grub/mm.h>
 
 GRUB_MOD_LICENSE ("GPLv3+");
 
@@ -39,26 +40,30 @@ static const char *names[] =
     [GRUB_MEMORY_HOLE] = N_("Address range not associated with RAM")
   };
 
+#ifndef GRUB_MACHINE_EMU
+/* Helper for grub_cmd_lsmmap.  */
+static int
+lsmmap_hook (grub_uint64_t addr, grub_uint64_t size, grub_memory_type_t type,
+	     void *data __attribute__ ((unused)))
+{
+  if (type < ARRAY_SIZE (names) && names[type])
+    grub_printf_ (N_("base_addr = 0x%llx, length = 0x%llx, %s\n"),
+		  (long long) addr, (long long) size, _(names[type]));
+  else
+    grub_printf_ (N_("base_addr = 0x%llx, length = 0x%llx, type = 0x%x\n"),
+		  (long long) addr, (long long) size, type);
+  return 0;
+}
+#endif
+
 static grub_err_t
 grub_cmd_lsmmap (grub_command_t cmd __attribute__ ((unused)),
 		 int argc __attribute__ ((unused)),
 		 char **args __attribute__ ((unused)))
 
 {
-  auto int NESTED_FUNC_ATTR hook (grub_uint64_t, grub_uint64_t, grub_memory_type_t);
-  int NESTED_FUNC_ATTR hook (grub_uint64_t addr, grub_uint64_t size, 
-			     grub_memory_type_t type)
-    {
-      if (type < ARRAY_SIZE (names) && names[type])
-	grub_printf_ (N_("base_addr = 0x%llx, length = 0x%llx, %s\n"),
-		      (long long) addr, (long long) size, _(names[type]));
-      else
-	grub_printf_ (N_("base_addr = 0x%llx, length = 0x%llx, type = 0x%x\n"),
-		      (long long) addr, (long long) size, type);
-      return 0;
-    }
 #ifndef GRUB_MACHINE_EMU
-  grub_machine_mmap_iterate (hook);
+  grub_machine_mmap_iterate (lsmmap_hook, NULL);
 #endif
 
   return 0;
diff --git a/grub-core/efiemu/mm.c b/grub-core/efiemu/mm.c
index 10cbc68..d4a4f3a 100644
--- a/grub-core/efiemu/mm.c
+++ b/grub-core/efiemu/mm.c
@@ -268,26 +268,26 @@ grub_efiemu_mm_return_request (int handle)
       }
 }
 
+/* Helper for grub_efiemu_mmap_init.  */
+static int
+bounds_hook (grub_uint64_t addr __attribute__ ((unused)),
+	     grub_uint64_t size __attribute__ ((unused)),
+	     grub_memory_type_t type __attribute__ ((unused)),
+	     void *data __attribute__ ((unused)))
+{
+  mmap_reserved_size++;
+  return 0;
+}
+
 /* Reserve space for memory map */
 static grub_err_t
 grub_efiemu_mmap_init (void)
 {
-  auto int NESTED_FUNC_ATTR bounds_hook (grub_uint64_t, grub_uint64_t,
-					 grub_memory_type_t);
-  int NESTED_FUNC_ATTR bounds_hook (grub_uint64_t addr __attribute__ ((unused)),
-				    grub_uint64_t size __attribute__ ((unused)),
-				    grub_memory_type_t type
-				    __attribute__ ((unused)))
-    {
-      mmap_reserved_size++;
-      return 0;
-    }
-
   // the place for memory used by efiemu itself
   mmap_reserved_size = GRUB_EFI_MAX_MEMORY_TYPE + 1;
 
 #ifndef GRUB_MACHINE_EMU
-  grub_machine_mmap_iterate (bounds_hook);
+  grub_machine_mmap_iterate (bounds_hook, NULL);
 #endif
 
   return GRUB_ERR_NONE;
@@ -383,48 +383,47 @@ grub_efiemu_mm_init (void)
   return GRUB_ERR_NONE;
 }
 
+/* Helper for grub_efiemu_mmap_fill.  */
+static int
+fill_hook (grub_uint64_t addr, grub_uint64_t size, grub_memory_type_t type,
+	   void *data __attribute__ ((unused)))
+  {
+    switch (type)
+      {
+      case GRUB_MEMORY_AVAILABLE:
+	return grub_efiemu_add_to_mmap (addr, size,
+					GRUB_EFI_CONVENTIONAL_MEMORY);
+
+      case GRUB_MEMORY_ACPI:
+	return grub_efiemu_add_to_mmap (addr, size,
+					GRUB_EFI_ACPI_RECLAIM_MEMORY);
+
+      case GRUB_MEMORY_NVS:
+	return grub_efiemu_add_to_mmap (addr, size,
+					GRUB_EFI_ACPI_MEMORY_NVS);
+
+      default:
+	grub_dprintf ("efiemu",
+		      "Unknown memory type %d. Assuming unusable\n", type);
+      case GRUB_MEMORY_RESERVED:
+	return grub_efiemu_add_to_mmap (addr, size,
+					GRUB_EFI_UNUSABLE_MEMORY);
+      }
+  }
+
 /* Copy host memory map */
 static grub_err_t
 grub_efiemu_mmap_fill (void)
 {
-  auto int NESTED_FUNC_ATTR fill_hook (grub_uint64_t, grub_uint64_t,
-				       grub_memory_type_t);
-  int NESTED_FUNC_ATTR fill_hook (grub_uint64_t addr,
-				  grub_uint64_t size,
-				  grub_memory_type_t type)
-    {
-      switch (type)
-	{
-	case GRUB_MEMORY_AVAILABLE:
-	  return grub_efiemu_add_to_mmap (addr, size,
-					  GRUB_EFI_CONVENTIONAL_MEMORY);
-
-	case GRUB_MEMORY_ACPI:
-	  return grub_efiemu_add_to_mmap (addr, size,
-					  GRUB_EFI_ACPI_RECLAIM_MEMORY);
-
-	case GRUB_MEMORY_NVS:
-	  return grub_efiemu_add_to_mmap (addr, size,
-					  GRUB_EFI_ACPI_MEMORY_NVS);
-
-	default:
-	  grub_dprintf ("efiemu",
-			"Unknown memory type %d. Assuming unusable\n", type);
-	case GRUB_MEMORY_RESERVED:
-	  return grub_efiemu_add_to_mmap (addr, size,
-					  GRUB_EFI_UNUSABLE_MEMORY);
-	}
-    }
-
 #ifndef GRUB_MACHINE_EMU
-  grub_machine_mmap_iterate (fill_hook);
+  grub_machine_mmap_iterate (fill_hook, NULL);
 #endif
 
   return GRUB_ERR_NONE;
 }
 
 grub_err_t
-grub_efiemu_mmap_iterate (grub_memory_hook_t hook)
+grub_efiemu_mmap_iterate (grub_memory_hook_t hook, void *hook_data)
 {
   unsigned i;
 
@@ -433,12 +432,12 @@ grub_efiemu_mmap_iterate (grub_memory_hook_t hook)
       {
       case GRUB_EFI_RUNTIME_SERVICES_CODE:
 	hook (efiemu_mmap[i].physical_start, efiemu_mmap[i].num_pages * 4096,
-	      GRUB_MEMORY_CODE);
+	      GRUB_MEMORY_CODE, hook_data);
 	break;
 
       case GRUB_EFI_UNUSABLE_MEMORY:
 	hook (efiemu_mmap[i].physical_start, efiemu_mmap[i].num_pages * 4096,
-	      GRUB_MEMORY_BADRAM);
+	      GRUB_MEMORY_BADRAM, hook_data);
 	break;
 
       case GRUB_EFI_RESERVED_MEMORY_TYPE:
@@ -448,7 +447,7 @@ grub_efiemu_mmap_iterate (grub_memory_hook_t hook)
       case GRUB_EFI_PAL_CODE:
       case GRUB_EFI_MAX_MEMORY_TYPE:
 	hook (efiemu_mmap[i].physical_start, efiemu_mmap[i].num_pages * 4096,
-	      GRUB_MEMORY_RESERVED);
+	      GRUB_MEMORY_RESERVED, hook_data);
 	break;
 
       case GRUB_EFI_LOADER_CODE:
@@ -457,17 +456,17 @@ grub_efiemu_mmap_iterate (grub_memory_hook_t hook)
       case GRUB_EFI_BOOT_SERVICES_DATA:
       case GRUB_EFI_CONVENTIONAL_MEMORY:
 	hook (efiemu_mmap[i].physical_start, efiemu_mmap[i].num_pages * 4096,
-	      GRUB_MEMORY_AVAILABLE);
+	      GRUB_MEMORY_AVAILABLE, hook_data);
 	break;
 
       case GRUB_EFI_ACPI_RECLAIM_MEMORY:
 	hook (efiemu_mmap[i].physical_start, efiemu_mmap[i].num_pages * 4096,
-	      GRUB_MEMORY_ACPI);
+	      GRUB_MEMORY_ACPI, hook_data);
 	break;
 
       case GRUB_EFI_ACPI_MEMORY_NVS:
 	hook (efiemu_mmap[i].physical_start, efiemu_mmap[i].num_pages * 4096,
-	      GRUB_MEMORY_NVS);
+	      GRUB_MEMORY_NVS, hook_data);
 	break;
       }
 
diff --git a/grub-core/kern/i386/coreboot/init.c b/grub-core/kern/i386/coreboot/init.c
index 52fbba4..48fd1a6 100644
--- a/grub-core/kern/i386/coreboot/init.c
+++ b/grub-core/kern/i386/coreboot/init.c
@@ -57,6 +57,39 @@ grub_addr_t grub_modbase;
 grub_addr_t grub_modbase = ALIGN_UP((grub_addr_t) _end, GRUB_KERNEL_MACHINE_MOD_ALIGN);
 #endif
 
+/* Helper for grub_machine_init.  */
+static int
+heap_init (grub_uint64_t addr, grub_uint64_t size, grub_memory_type_t type,
+	   void *data __attribute__ ((unused)))
+{
+#if GRUB_CPU_SIZEOF_VOID_P == 4
+  /* Restrict ourselves to 32-bit memory space.  */
+  if (addr > GRUB_ULONG_MAX)
+    return 0;
+  if (addr + size > GRUB_ULONG_MAX)
+    size = GRUB_ULONG_MAX - addr;
+#endif
+
+  if (type != GRUB_MEMORY_AVAILABLE)
+    return 0;
+
+  /* Avoid the lower memory.  */
+  if (addr < GRUB_MEMORY_MACHINE_LOWER_SIZE)
+    {
+      if (addr + size <= GRUB_MEMORY_MACHINE_LOWER_SIZE)
+	return 0;
+      else
+	{
+	  size -= GRUB_MEMORY_MACHINE_LOWER_SIZE - addr;
+	  addr = GRUB_MEMORY_MACHINE_LOWER_SIZE;
+	}
+    }
+
+  grub_mm_init_region ((void *) (grub_addr_t) addr, (grub_size_t) size);
+
+  return 0;
+}
+
 void
 grub_machine_init (void)
 {
@@ -68,43 +101,10 @@ grub_machine_init (void)
   /* Initialize the console as early as possible.  */
   grub_vga_text_init ();
 
-  auto int NESTED_FUNC_ATTR heap_init (grub_uint64_t, grub_uint64_t, 
-				       grub_memory_type_t);
-  int NESTED_FUNC_ATTR heap_init (grub_uint64_t addr, grub_uint64_t size,
-				  grub_memory_type_t type)
-  {
-#if GRUB_CPU_SIZEOF_VOID_P == 4
-    /* Restrict ourselves to 32-bit memory space.  */
-    if (addr > GRUB_ULONG_MAX)
-      return 0;
-    if (addr + size > GRUB_ULONG_MAX)
-      size = GRUB_ULONG_MAX - addr;
-#endif
-
-    if (type != GRUB_MEMORY_AVAILABLE)
-      return 0;
-
-    /* Avoid the lower memory.  */
-    if (addr < GRUB_MEMORY_MACHINE_LOWER_SIZE)
-      {
-	if (addr + size <= GRUB_MEMORY_MACHINE_LOWER_SIZE)
-	  return 0;
-	else
-	  {
-	    size -= GRUB_MEMORY_MACHINE_LOWER_SIZE - addr;
-	    addr = GRUB_MEMORY_MACHINE_LOWER_SIZE;
-	  }
-      }
-
-    grub_mm_init_region ((void *) (grub_addr_t) addr, (grub_size_t) size);
-
-    return 0;
-  }
-
 #if defined (GRUB_MACHINE_MULTIBOOT) || defined (GRUB_MACHINE_QEMU)
   grub_machine_mmap_init ();
 #endif
-  grub_machine_mmap_iterate (heap_init);
+  grub_machine_mmap_iterate (heap_init, NULL);
 
   grub_tsc_init ();
 }
diff --git a/grub-core/kern/i386/coreboot/mmap.c b/grub-core/kern/i386/coreboot/mmap.c
index 8e15683..ae4af08 100644
--- a/grub-core/kern/i386/coreboot/mmap.c
+++ b/grub-core/kern/i386/coreboot/mmap.c
@@ -33,7 +33,9 @@ check_signature (grub_linuxbios_table_header_t tbl_header)
 }
 
 static grub_err_t
-grub_linuxbios_table_iterate (int (*hook) (grub_linuxbios_table_item_t))
+grub_linuxbios_table_iterate (int (*hook) (grub_linuxbios_table_item_t,
+					   void *),
+			      void *hook_data)
 {
   grub_linuxbios_table_header_t table_header;
   grub_linuxbios_table_item_t table_item;
@@ -68,42 +70,54 @@ signature_found:
            *(grub_uint64_t *) (table_item + 1);
          goto signature_found;   
        }
-      if (hook (table_item))
+      if (hook (table_item, hook_data))
        return 1;
     }
 
   return 0;
 }
 
-grub_err_t
-grub_machine_mmap_iterate (grub_memory_hook_t hook)
+/* Context for grub_machine_mmap_iterate.  */
+struct grub_machine_mmap_iterate_ctx
 {
-  mem_region_t mem_region;
+  grub_memory_hook_t hook;
+  void *hook_data;
+};
 
-  auto int iterate_linuxbios_table (grub_linuxbios_table_item_t);
-  int iterate_linuxbios_table (grub_linuxbios_table_item_t table_item)
-  {
-    if (table_item->tag != GRUB_LINUXBIOS_MEMBER_MEMORY)
-      return 0;
-
-    mem_region =
-      (mem_region_t) ((long) table_item +
-				 sizeof (struct grub_linuxbios_table_item));
-    while ((long) mem_region < (long) table_item + (long) table_item->size)
-      {
-	if (hook (mem_region->addr, mem_region->size,
-		  /* Multiboot mmaps match with the coreboot mmap definition.
-		     Therefore, we can just pass type through.  */
-		  mem_region->type))
-	  return 1;
-
-	mem_region++;
-      }
+/* Helper for grub_machine_mmap_iterate.  */
+static int
+iterate_linuxbios_table (grub_linuxbios_table_item_t table_item, void *data)
+{
+  struct grub_machine_mmap_iterate_ctx *ctx = data;
+  mem_region_t mem_region;
 
+  if (table_item->tag != GRUB_LINUXBIOS_MEMBER_MEMORY)
     return 0;
-  }
 
-  grub_linuxbios_table_iterate (iterate_linuxbios_table);
+  mem_region =
+    (mem_region_t) ((long) table_item +
+			       sizeof (struct grub_linuxbios_table_item));
+  while ((long) mem_region < (long) table_item + (long) table_item->size)
+    {
+      if (ctx->hook (mem_region->addr, mem_region->size,
+		     /* Multiboot mmaps match with the coreboot mmap
+		        definition.  Therefore, we can just pass type
+		        through.  */
+		     mem_region->type, ctx->hook_data))
+	return 1;
+
+      mem_region++;
+    }
+
+  return 0;
+}
+
+grub_err_t
+grub_machine_mmap_iterate (grub_memory_hook_t hook, void *hook_data)
+{
+  struct grub_machine_mmap_iterate_ctx ctx = { hook, hook_data };
+
+  grub_linuxbios_table_iterate (iterate_linuxbios_table, &ctx);
 
   return 0;
 }
diff --git a/grub-core/kern/i386/multiboot_mmap.c b/grub-core/kern/i386/multiboot_mmap.c
index 1cb422f..e8f4f34 100644
--- a/grub-core/kern/i386/multiboot_mmap.c
+++ b/grub-core/kern/i386/multiboot_mmap.c
@@ -57,13 +57,13 @@ grub_machine_mmap_init (void)
 }
 
 grub_err_t
-grub_machine_mmap_iterate (grub_memory_hook_t hook)
+grub_machine_mmap_iterate (grub_memory_hook_t hook, void *hook_data)
 {
   struct multiboot_mmap_entry *entry = (void *) kern_multiboot_info.mmap_addr;
 
   while ((unsigned long) entry < kern_multiboot_info.mmap_addr + kern_multiboot_info.mmap_length)
     {
-      if (hook (entry->addr, entry->len, entry->type))
+      if (hook (entry->addr, entry->len, entry->type, hook_data))
 	break;
 
       entry = (void *) ((grub_addr_t) entry + entry->size + sizeof (entry->size));
diff --git a/grub-core/kern/i386/pc/init.c b/grub-core/kern/i386/pc/init.c
index 0841d8b..7d8b12c 100644
--- a/grub-core/kern/i386/pc/init.c
+++ b/grub-core/kern/i386/pc/init.c
@@ -154,6 +154,36 @@ compact_mem_regions (void)
 grub_addr_t grub_modbase;
 extern grub_uint8_t _start[], _edata[];
 
+/* Helper for grub_machine_init.  */
+static int
+mmap_iterate_hook (grub_uint64_t addr, grub_uint64_t size,
+		   grub_memory_type_t type,
+		   void *data __attribute__ ((unused)))
+{
+  /* Avoid the lower memory.  */
+  if (addr < 0x100000)
+    {
+      if (size <= 0x100000 - addr)
+	return 0;
+
+      size -= 0x100000 - addr;
+      addr = 0x100000;
+    }
+
+  /* Ignore >4GB.  */
+  if (addr <= 0xFFFFFFFF && type == GRUB_MEMORY_AVAILABLE)
+    {
+      grub_size_t len;
+
+      len = (grub_size_t) ((addr + size > 0xFFFFFFFF)
+	     ? 0xFFFFFFFF - addr
+	     : size);
+      add_mem_region (addr, len);
+    }
+
+  return 0;
+}
+
 void
 grub_machine_init (void)
 {
@@ -188,36 +218,7 @@ grub_machine_init (void)
 		    grub_lower_mem - GRUB_MEMORY_MACHINE_RESERVED_END);
 #endif
 
-  auto int NESTED_FUNC_ATTR hook (grub_uint64_t, grub_uint64_t,
-				  grub_memory_type_t);
-  int NESTED_FUNC_ATTR hook (grub_uint64_t addr, grub_uint64_t size,
-			     grub_memory_type_t type)
-    {
-      /* Avoid the lower memory.  */
-      if (addr < 0x100000)
-	{
-	  if (size <= 0x100000 - addr)
-	    return 0;
-
-	  size -= 0x100000 - addr;
-	  addr = 0x100000;
-	}
-
-      /* Ignore >4GB.  */
-      if (addr <= 0xFFFFFFFF && type == GRUB_MEMORY_AVAILABLE)
-	{
-	  grub_size_t len;
-
-	  len = (grub_size_t) ((addr + size > 0xFFFFFFFF)
-		 ? 0xFFFFFFFF - addr
-		 : size);
-	  add_mem_region (addr, len);
-	}
-
-      return 0;
-    }
-
-  grub_machine_mmap_iterate (hook);
+  grub_machine_mmap_iterate (mmap_iterate_hook, NULL);
 
   compact_mem_regions ();
 
diff --git a/grub-core/kern/i386/pc/mmap.c b/grub-core/kern/i386/pc/mmap.c
index 480ffa9..7e5feea 100644
--- a/grub-core/kern/i386/pc/mmap.c
+++ b/grub-core/kern/i386/pc/mmap.c
@@ -139,7 +139,7 @@ grub_get_mmap_entry (struct grub_machine_mmap_entry *entry,
 }
 
 grub_err_t
-grub_machine_mmap_iterate (grub_memory_hook_t hook)
+grub_machine_mmap_iterate (grub_memory_hook_t hook, void *hook_data)
 {
   grub_uint32_t cont;
   struct grub_machine_mmap_entry *entry
@@ -156,7 +156,8 @@ grub_machine_mmap_iterate (grub_memory_hook_t hook)
 	if (hook (entry->addr, entry->len,
 		  /* GRUB mmaps have been defined to match with the E820 definition.
 		     Therefore, we can just pass type through.  */
-		  ((entry->type <= GRUB_MACHINE_MEMORY_BADRAM) && (entry->type >= GRUB_MACHINE_MEMORY_AVAILABLE)) ? entry->type : GRUB_MEMORY_RESERVED))
+		  ((entry->type <= GRUB_MACHINE_MEMORY_BADRAM) && (entry->type >= GRUB_MACHINE_MEMORY_AVAILABLE)) ? entry->type : GRUB_MEMORY_RESERVED,
+		  hook_data))
 	  break;
 
 	if (! cont)
@@ -172,18 +173,19 @@ grub_machine_mmap_iterate (grub_memory_hook_t hook)
       grub_uint32_t eisa_mmap = grub_get_eisa_mmap ();
 
       if (hook (0x0, ((grub_uint32_t) grub_get_conv_memsize ()) << 10,
-		GRUB_MEMORY_AVAILABLE))
+		GRUB_MEMORY_AVAILABLE, hook_data))
 	return 0;
 
       if (eisa_mmap)
 	{
 	  if (hook (0x100000, (eisa_mmap & 0xFFFF) << 10,
-		    GRUB_MEMORY_AVAILABLE) == 0)
-	    hook (0x1000000, eisa_mmap & ~0xFFFF, GRUB_MEMORY_AVAILABLE);
+		    GRUB_MEMORY_AVAILABLE, hook_data) == 0)
+	    hook (0x1000000, eisa_mmap & ~0xFFFF, GRUB_MEMORY_AVAILABLE,
+		  hook_data);
 	}
       else
 	hook (0x100000, ((grub_uint32_t) grub_get_ext_memsize ()) << 10,
-	      GRUB_MEMORY_AVAILABLE);
+	      GRUB_MEMORY_AVAILABLE, hook_data);
     }
 
   return 0;
diff --git a/grub-core/kern/i386/qemu/mmap.c b/grub-core/kern/i386/qemu/mmap.c
index ffb61a4..f449637 100644
--- a/grub-core/kern/i386/qemu/mmap.c
+++ b/grub-core/kern/i386/qemu/mmap.c
@@ -69,38 +69,38 @@ grub_machine_mmap_init (void)
 }
 
 grub_err_t
-grub_machine_mmap_iterate (grub_memory_hook_t hook)
+grub_machine_mmap_iterate (grub_memory_hook_t hook, void *hook_data)
 {
   if (hook (0x0,
 	    (grub_addr_t) _start,
-	    GRUB_MEMORY_AVAILABLE))
+	    GRUB_MEMORY_AVAILABLE, hook_data))
     return 1;
 
   if (hook ((grub_addr_t) _end,
            0xa0000 - (grub_addr_t) _end,
-           GRUB_MEMORY_AVAILABLE))
+           GRUB_MEMORY_AVAILABLE, hook_data))
     return 1;
 
   if (hook (GRUB_MEMORY_MACHINE_UPPER,
 	    0x100000 - GRUB_MEMORY_MACHINE_UPPER,
-	    GRUB_MEMORY_RESERVED))
+	    GRUB_MEMORY_RESERVED, hook_data))
     return 1;
 
   /* Everything else is free.  */
   if (hook (0x100000,
 	    min (mem_size, (grub_uint32_t) -GRUB_BOOT_MACHINE_SIZE) - 0x100000,
-	    GRUB_MEMORY_AVAILABLE))
+	    GRUB_MEMORY_AVAILABLE, hook_data))
     return 1;
 
   /* Protect boot.img, which contains the gdt.  It is mapped at the top of memory
      (it is also mapped below 0x100000, but we already reserved that area).  */
   if (hook ((grub_uint32_t) -GRUB_BOOT_MACHINE_SIZE,
 	    GRUB_BOOT_MACHINE_SIZE,
-	    GRUB_MEMORY_RESERVED))
+	    GRUB_MEMORY_RESERVED, hook_data))
     return 1;
 
   if (above_4g != 0 && hook (0x100000000ULL, above_4g,
-			     GRUB_MEMORY_AVAILABLE))
+			     GRUB_MEMORY_AVAILABLE, hook_data))
     return 1;
 
   return 0;
diff --git a/grub-core/kern/ieee1275/init.c b/grub-core/kern/ieee1275/init.c
index 14dcdf0..0894cb6 100644
--- a/grub-core/kern/ieee1275/init.c
+++ b/grub-core/kern/ieee1275/init.c
@@ -156,74 +156,76 @@ grub_claim_heap (void)
 				 + GRUB_KERNEL_MACHINE_STACK_SIZE), 0x200000);
 }
 #else
+/* Helper for grub_claim_heap.  */
+static int
+heap_init (grub_uint64_t addr, grub_uint64_t len, grub_memory_type_t type,
+	   void *data)
+{
+  unsigned long *total = data;
+
+  if (type != 1)
+    return 0;
+
+  if (grub_ieee1275_test_flag (GRUB_IEEE1275_FLAG_NO_PRE1_5M_CLAIM))
+    {
+      if (addr + len <= 0x180000)
+	return 0;
+
+      if (addr < 0x180000)
+	{
+	  len = addr + len - 0x180000;
+	  addr = 0x180000;
+	}
+    }
+  len -= 1; /* Required for some firmware.  */
+
+  /* Never exceed HEAP_MAX_SIZE  */
+  if (*total + len > HEAP_MAX_SIZE)
+    len = HEAP_MAX_SIZE - *total;
+
+  /* Avoid claiming anything above HEAP_MAX_ADDR, if possible. */
+  if ((addr < HEAP_MAX_ADDR) &&				/* if it's too late, don't bother */
+      (addr + len > HEAP_MAX_ADDR) &&				/* if it wasn't available anyway, don't bother */
+      (*total + (HEAP_MAX_ADDR - addr) > HEAP_MIN_SIZE))	/* only limit ourselves when we can afford to */
+     len = HEAP_MAX_ADDR - addr;
+
+  /* In theory, firmware should already prevent this from happening by not
+     listing our own image in /memory/available.  The check below is intended
+     as a safeguard in case that doesn't happen.  However, it doesn't protect
+     us from corrupting our module area, which extends up to a
+     yet-undetermined region above _end.  */
+  if ((addr < (grub_addr_t) _end) && ((addr + len) > (grub_addr_t) _start))
+    {
+      grub_printf ("Warning: attempt to claim over our own code!\n");
+      len = 0;
+    }
+
+  if (len)
+    {
+      grub_err_t err;
+      /* Claim and use it.  */
+      err = grub_claimmap (addr, len);
+      if (err)
+	return err;
+      grub_mm_init_region ((void *) (grub_addr_t) addr, len);
+    }
+
+  *total += len;
+  if (*total >= HEAP_MAX_SIZE)
+    return 1;
+
+  return 0;
+}
+
 static void 
 grub_claim_heap (void)
 {
   unsigned long total = 0;
 
-  auto int NESTED_FUNC_ATTR heap_init (grub_uint64_t addr, grub_uint64_t len,
-				       grub_memory_type_t type);
-  int NESTED_FUNC_ATTR heap_init (grub_uint64_t addr, grub_uint64_t len,
-				  grub_memory_type_t type)
-  {
-    if (type != 1)
-      return 0;
-
-    if (grub_ieee1275_test_flag (GRUB_IEEE1275_FLAG_NO_PRE1_5M_CLAIM))
-      {
-	if (addr + len <= 0x180000)
-	  return 0;
-
-	if (addr < 0x180000)
-	  {
-	    len = addr + len - 0x180000;
-	    addr = 0x180000;
-	  }
-      }
-    len -= 1; /* Required for some firmware.  */
-
-    /* Never exceed HEAP_MAX_SIZE  */
-    if (total + len > HEAP_MAX_SIZE)
-      len = HEAP_MAX_SIZE - total;
-
-    /* Avoid claiming anything above HEAP_MAX_ADDR, if possible. */
-    if ((addr < HEAP_MAX_ADDR) &&				/* if it's too late, don't bother */
-        (addr + len > HEAP_MAX_ADDR) &&				/* if it wasn't available anyway, don't bother */
-        (total + (HEAP_MAX_ADDR - addr) > HEAP_MIN_SIZE))	/* only limit ourselves when we can afford to */
-       len = HEAP_MAX_ADDR - addr;
-
-    /* In theory, firmware should already prevent this from happening by not
-       listing our own image in /memory/available.  The check below is intended
-       as a safeguard in case that doesn't happen.  However, it doesn't protect
-       us from corrupting our module area, which extends up to a
-       yet-undetermined region above _end.  */
-    if ((addr < (grub_addr_t) _end) && ((addr + len) > (grub_addr_t) _start))
-      {
-        grub_printf ("Warning: attempt to claim over our own code!\n");
-        len = 0;
-      }
-
-    if (len)
-      {
-	grub_err_t err;
-	/* Claim and use it.  */
-	err = grub_claimmap (addr, len);
-	if (err)
-	  return err;
-	grub_mm_init_region ((void *) (grub_addr_t) addr, len);
-      }
-
-    total += len;
-    if (total >= HEAP_MAX_SIZE)
-      return 1;
-
-    return 0;
-  }
-
   if (grub_ieee1275_test_flag (GRUB_IEEE1275_FLAG_CANNOT_INTERPRET))
-    heap_init (HEAP_MAX_ADDR - HEAP_MIN_SIZE, HEAP_MIN_SIZE, 1);
+    heap_init (HEAP_MAX_ADDR - HEAP_MIN_SIZE, HEAP_MIN_SIZE, 1, &total);
   else
-    grub_machine_mmap_iterate (heap_init);
+    grub_machine_mmap_iterate (heap_init, &total);
 }
 #endif
 
diff --git a/grub-core/kern/ieee1275/mmap.c b/grub-core/kern/ieee1275/mmap.c
index 2e4e085..911bb00 100644
--- a/grub-core/kern/ieee1275/mmap.c
+++ b/grub-core/kern/ieee1275/mmap.c
@@ -21,7 +21,7 @@
 #include <grub/types.h>
 
 grub_err_t
-grub_machine_mmap_iterate (grub_memory_hook_t hook)
+grub_machine_mmap_iterate (grub_memory_hook_t hook, void *hook_data)
 {
   grub_ieee1275_phandle_t root;
   grub_ieee1275_phandle_t memory;
@@ -72,7 +72,7 @@ grub_machine_mmap_iterate (grub_memory_hook_t hook)
       if (size_cells == 2)
 	size = (size << 32) | available[i++];
 
-      if (hook (address, size, GRUB_MEMORY_AVAILABLE))
+      if (hook (address, size, GRUB_MEMORY_AVAILABLE, hook_data))
 	break;
     }
 
diff --git a/grub-core/kern/mips/arc/init.c b/grub-core/kern/mips/arc/init.c
index 44b4171..4d680ed 100644
--- a/grub-core/kern/mips/arc/init.c
+++ b/grub-core/kern/mips/arc/init.c
@@ -91,7 +91,7 @@ grub_arc_iterate_devs (int (*hook) (const char *name,
 }
 
 grub_err_t
-grub_machine_mmap_iterate (grub_memory_hook_t hook)
+grub_machine_mmap_iterate (grub_memory_hook_t hook, void *hook_data)
 {
   struct grub_arc_memory_descriptor *cur = NULL;
   while (1)
@@ -120,7 +120,7 @@ grub_machine_mmap_iterate (grub_memory_hook_t hook)
 	  break;
 	}
       if (hook (((grub_uint64_t) cur->start_page) << 12,
-		((grub_uint64_t) cur->num_pages)  << 12, type))
+		((grub_uint64_t) cur->num_pages)  << 12, type, hook_data))
 	return GRUB_ERR_NONE;
     }
 }
diff --git a/grub-core/kern/mips/loongson/init.c b/grub-core/kern/mips/loongson/init.c
index 2109a67..756439b 100644
--- a/grub-core/kern/mips/loongson/init.c
+++ b/grub-core/kern/mips/loongson/init.c
@@ -40,12 +40,12 @@
 #include <grub/at_keyboard.h>
 
 grub_err_t
-grub_machine_mmap_iterate (grub_memory_hook_t hook)
+grub_machine_mmap_iterate (grub_memory_hook_t hook, void *hook_data)
 {
   hook (GRUB_ARCH_LOWMEMPSTART, grub_arch_memsize << 20,
-	GRUB_MEMORY_AVAILABLE);
+	GRUB_MEMORY_AVAILABLE, hook_data);
   hook (GRUB_ARCH_HIGHMEMPSTART, grub_arch_highmemsize << 20,
-	GRUB_MEMORY_AVAILABLE);
+	GRUB_MEMORY_AVAILABLE, hook_data);
   return GRUB_ERR_NONE;
 }
 
diff --git a/grub-core/kern/mips/qemu_mips/init.c b/grub-core/kern/mips/qemu_mips/init.c
index 782f17f..aa414eb 100644
--- a/grub-core/kern/mips/qemu_mips/init.c
+++ b/grub-core/kern/mips/qemu_mips/init.c
@@ -92,9 +92,9 @@ grub_halt (void)
 }
 
 grub_err_t 
-grub_machine_mmap_iterate (grub_memory_hook_t hook)
+grub_machine_mmap_iterate (grub_memory_hook_t hook, void *hook_data)
 {
-  hook (0, grub_arch_memsize, GRUB_MEMORY_AVAILABLE);
+  hook (0, grub_arch_memsize, GRUB_MEMORY_AVAILABLE, hook_data);
   return GRUB_ERR_NONE;
 }
 
diff --git a/grub-core/lib/ieee1275/relocator.c b/grub-core/lib/ieee1275/relocator.c
index 021f0ce..f6ecadd 100644
--- a/grub-core/lib/ieee1275/relocator.c
+++ b/grub-core/lib/ieee1275/relocator.c
@@ -21,65 +21,81 @@
 #include <grub/memory.h>
 #include <grub/ieee1275/ieee1275.h>
 
+/* Helper for grub_relocator_firmware_get_max_events.  */
+static int
+count (grub_uint64_t addr __attribute__ ((unused)),
+       grub_uint64_t len __attribute__ ((unused)),
+       grub_memory_type_t type __attribute__ ((unused)), void *data)
+{
+  int *counter = data;
+
+  (*counter)++;
+  return 0;
+}
+
 unsigned 
 grub_relocator_firmware_get_max_events (void)
 {
   int counter = 0;
-  auto int NESTED_FUNC_ATTR count (grub_uint64_t addr __attribute__ ((unused)),
-				   grub_uint64_t len __attribute__ ((unused)),
-				   grub_memory_type_t type __attribute__ ((unused)));
-  int NESTED_FUNC_ATTR count (grub_uint64_t addr __attribute__ ((unused)), 
-			      grub_uint64_t len __attribute__ ((unused)), 
-			      grub_memory_type_t type __attribute__ ((unused)))
-  {
-    counter++;
-    return 0;
-  }
 
   if (grub_ieee1275_test_flag (GRUB_IEEE1275_FLAG_CANNOT_INTERPRET))
     return 0;
-  grub_machine_mmap_iterate (count);
+  grub_machine_mmap_iterate (count, &counter);
   return 2 * counter;
 }
 
-unsigned 
-grub_relocator_firmware_fill_events (struct grub_relocator_mmap_event *events)
+/* Context for grub_relocator_firmware_fill_events.  */
+struct grub_relocator_firmware_fill_events_ctx
 {
-  int counter = 0;
-  auto int NESTED_FUNC_ATTR fill (grub_uint64_t addr, grub_uint64_t len,
-				  grub_memory_type_t type);
-  int NESTED_FUNC_ATTR fill (grub_uint64_t addr, grub_uint64_t len,
-			     grub_memory_type_t type)
-  {
-    if (type != GRUB_MEMORY_AVAILABLE)
-      return 0;
-
-    if (grub_ieee1275_test_flag (GRUB_IEEE1275_FLAG_NO_PRE1_5M_CLAIM))
-      {
-	if (addr + len <= 0x180000)
-	  return 0;
-
-	if (addr < 0x180000)
-	  {
-	    len = addr + len - 0x180000;
-	    addr = 0x180000;
-	  }
-      }
-
-    events[counter].type = REG_FIRMWARE_START;
-    events[counter].pos = addr;
-    counter++;
-    events[counter].type = REG_FIRMWARE_END;
-    events[counter].pos = addr + len;
-    counter++;
+  struct grub_relocator_mmap_event *events;
+  int counter;
+};
+
+/* Helper for grub_relocator_firmware_fill_events.  */
+static int
+grub_relocator_firmware_fill_events_iter (grub_uint64_t addr,
+					  grub_uint64_t len,
+					  grub_memory_type_t type, void *data)
+{
+  struct grub_relocator_firmware_fill_events_ctx *ctx = data;
 
+  if (type != GRUB_MEMORY_AVAILABLE)
     return 0;
-  }
+
+  if (grub_ieee1275_test_flag (GRUB_IEEE1275_FLAG_NO_PRE1_5M_CLAIM))
+    {
+      if (addr + len <= 0x180000)
+	return 0;
+
+      if (addr < 0x180000)
+	{
+	  len = addr + len - 0x180000;
+	  addr = 0x180000;
+	}
+    }
+
+  ctx->events[ctx->counter].type = REG_FIRMWARE_START;
+  ctx->events[ctx->counter].pos = addr;
+  ctx->counter++;
+  ctx->events[ctx->counter].type = REG_FIRMWARE_END;
+  ctx->events[ctx->counter].pos = addr + len;
+  ctx->counter++;
+
+  return 0;
+}
+
+unsigned 
+grub_relocator_firmware_fill_events (struct grub_relocator_mmap_event *events)
+{
+  struct grub_relocator_firmware_fill_events_ctx ctx = {
+    .events = events,
+    .counter = 0
+  };
 
   if (grub_ieee1275_test_flag (GRUB_IEEE1275_FLAG_CANNOT_INTERPRET))
     return 0;
-  grub_machine_mmap_iterate (fill);
-  return counter;
+  grub_machine_mmap_iterate (grub_relocator_firmware_fill_events_iter, &ctx);
+  return ctx.counter;
 }
 
 int
diff --git a/grub-core/lib/relocator.c b/grub-core/lib/relocator.c
index a45040a..350066d 100644
--- a/grub-core/lib/relocator.c
+++ b/grub-core/lib/relocator.c
@@ -1313,6 +1313,45 @@ grub_relocator_alloc_chunk_addr (struct grub_relocator *rel,
   return GRUB_ERR_NONE;
 }
 
+/* Context for grub_relocator_alloc_chunk_align.  */
+struct grub_relocator_alloc_chunk_align_ctx
+{
+  grub_phys_addr_t min_addr, max_addr;
+  grub_size_t size, align;
+  int preference;
+  struct grub_relocator_chunk *chunk;
+  int found;
+};
+
+/* Helper for grub_relocator_alloc_chunk_align.  */
+static int
+grub_relocator_alloc_chunk_align_iter (grub_uint64_t addr, grub_uint64_t sz,
+				       grub_memory_type_t type, void *data)
+{
+  struct grub_relocator_alloc_chunk_align_ctx *ctx = data;
+  grub_uint64_t candidate;
+
+  if (type != GRUB_MEMORY_AVAILABLE)
+    return 0;
+  candidate = ALIGN_UP (addr, ctx->align);
+  if (candidate < ctx->min_addr)
+    candidate = ALIGN_UP (ctx->min_addr, ctx->align);
+  if (candidate + ctx->size > addr + sz
+      || candidate > ALIGN_DOWN (ctx->max_addr, ctx->align))
+    return 0;
+  if (ctx->preference == GRUB_RELOCATOR_PREFERENCE_HIGH)
+    candidate = ALIGN_DOWN (min (addr + sz - ctx->size, ctx->max_addr),
+			    ctx->align);
+  if (!ctx->found || (ctx->preference == GRUB_RELOCATOR_PREFERENCE_HIGH
+		      && candidate > ctx->chunk->target))
+    ctx->chunk->target = candidate;
+  if (!ctx->found || (ctx->preference == GRUB_RELOCATOR_PREFERENCE_LOW
+		      && candidate < ctx->chunk->target))
+    ctx->chunk->target = candidate;
+  ctx->found = 1;
+  return 0;
+}
+
 grub_err_t
 grub_relocator_alloc_chunk_align (struct grub_relocator *rel,
 				  grub_relocator_chunk_t *out,
@@ -1322,8 +1361,15 @@ grub_relocator_alloc_chunk_align (struct grub_relocator *rel,
 				  int preference,
 				  int avoid_efi_boot_services)
 {
+  struct grub_relocator_alloc_chunk_align_ctx ctx = {
+    .min_addr = min_addr,
+    .max_addr = max_addr,
+    .size = size,
+    .align = align,
+    .preference = preference,
+    .found = 0
+  };
   grub_addr_t min_addr2 = 0, max_addr2;
-  struct grub_relocator_chunk *chunk;
 
   if (max_addr > ~size)
     max_addr = ~size;
@@ -1335,24 +1381,24 @@ grub_relocator_alloc_chunk_align (struct grub_relocator *rel,
 
   grub_dprintf ("relocator", "chunks = %p\n", rel->chunks);
 
-  chunk = grub_malloc (sizeof (struct grub_relocator_chunk));
-  if (!chunk)
+  ctx.chunk = grub_malloc (sizeof (struct grub_relocator_chunk));
+  if (!ctx.chunk)
     return grub_errno;
 
   if (malloc_in_range (rel, min_addr, max_addr, align,
-		       size, chunk,
+		       size, ctx.chunk,
 		       preference != GRUB_RELOCATOR_PREFERENCE_HIGH, 1))
     {
       grub_dprintf ("relocator", "allocated 0x%llx/0x%llx\n",
-		    (unsigned long long) chunk->src,
-		    (unsigned long long) chunk->src);
+		    (unsigned long long) ctx.chunk->src,
+		    (unsigned long long) ctx.chunk->src);
       grub_dprintf ("relocator", "chunks = %p\n", rel->chunks);
-      chunk->target = chunk->src;
-      chunk->size = size;
-      chunk->next = rel->chunks;
-      rel->chunks = chunk;
-      chunk->srcv = grub_map_memory (chunk->src, chunk->size);
-      *out = chunk;
+      ctx.chunk->target = ctx.chunk->src;
+      ctx.chunk->size = size;
+      ctx.chunk->next = rel->chunks;
+      rel->chunks = ctx.chunk;
+      ctx.chunk->srcv = grub_map_memory (ctx.chunk->src, ctx.chunk->size);
+      *out = ctx.chunk;
       return GRUB_ERR_NONE;
     }
 
@@ -1364,14 +1410,14 @@ grub_relocator_alloc_chunk_align (struct grub_relocator *rel,
   do
     {
       if (malloc_in_range (rel, min_addr2, max_addr2, align,
-			   size, chunk, 1, 1))
+			   size, ctx.chunk, 1, 1))
 	break;
 
       if (malloc_in_range (rel, rel->highestnonpostaddr, ~(grub_addr_t)0, 1,
-			   size, chunk, 0, 1))
+			   size, ctx.chunk, 0, 1))
 	{
-	  if (rel->postchunks > chunk->src)
-	    rel->postchunks = chunk->src;
+	  if (rel->postchunks > ctx.chunk->src)
+	    rel->postchunks = ctx.chunk->src;
 	  break;
 	}
 
@@ -1380,58 +1426,33 @@ grub_relocator_alloc_chunk_align (struct grub_relocator *rel,
   while (0);
 
   {
-    int found = 0;
-    auto int NESTED_FUNC_ATTR hook (grub_uint64_t, grub_uint64_t,
-				    grub_memory_type_t);
-    int NESTED_FUNC_ATTR hook (grub_uint64_t addr, grub_uint64_t sz,
-			       grub_memory_type_t type)
-    {
-      grub_uint64_t candidate;
-      if (type != GRUB_MEMORY_AVAILABLE)
-	return 0;
-      candidate = ALIGN_UP (addr, align);
-      if (candidate < min_addr)
-	candidate = ALIGN_UP (min_addr, align);
-      if (candidate + size > addr + sz
-	  || candidate > ALIGN_DOWN (max_addr, align))
-	return 0;
-      if (preference == GRUB_RELOCATOR_PREFERENCE_HIGH)
-	candidate = ALIGN_DOWN (min (addr + sz - size, max_addr), align);
-      if (!found || (preference == GRUB_RELOCATOR_PREFERENCE_HIGH
-		     && candidate > chunk->target))
-	chunk->target = candidate;
-      if (!found || (preference == GRUB_RELOCATOR_PREFERENCE_LOW
-		     && candidate < chunk->target))
-	chunk->target = candidate;
-      found = 1;
-      return 0;
-    }
-
 #ifdef GRUB_MACHINE_EFI
-    grub_efi_mmap_iterate (hook, avoid_efi_boot_services);
+    grub_efi_mmap_iterate (grub_relocator_alloc_chunk_align_iter, &ctx,
+			   avoid_efi_boot_services);
 #elif defined (__powerpc__)
     (void) avoid_efi_boot_services;
-    grub_machine_mmap_iterate (hook);
+    grub_machine_mmap_iterate (grub_relocator_alloc_chunk_align_iter, &ctx);
 #else
     (void) avoid_efi_boot_services;
-    grub_mmap_iterate (hook);
+    grub_mmap_iterate (grub_relocator_alloc_chunk_align_iter, &ctx);
 #endif
-    if (!found)
+    if (!ctx.found)
       return grub_error (GRUB_ERR_BAD_OS, "couldn't find suitable memory target");
   }
   while (1)
     {
       struct grub_relocator_chunk *chunk2;
       for (chunk2 = rel->chunks; chunk2; chunk2 = chunk2->next)
-	if ((chunk2->target <= chunk->target
-	     && chunk->target < chunk2->target + chunk2->size)
-	    || (chunk->target <= chunk2->target && chunk2->target
-		< chunk->target + size))
+	if ((chunk2->target <= ctx.chunk->target
+	     && ctx.chunk->target < chunk2->target + chunk2->size)
+	    || (ctx.chunk->target <= chunk2->target && chunk2->target
+		< ctx.chunk->target + size))
 	  {
 	    if (preference == GRUB_RELOCATOR_PREFERENCE_HIGH)
-	      chunk->target = ALIGN_DOWN (chunk2->target, align);
+	      ctx.chunk->target = ALIGN_DOWN (chunk2->target, align);
 	    else
-	      chunk->target = ALIGN_UP (chunk2->target + chunk2->size, align);
+	      ctx.chunk->target = ALIGN_UP (chunk2->target + chunk2->size,
+					    align);
 	    break;
 	  }
       if (!chunk2)
@@ -1441,23 +1462,23 @@ grub_relocator_alloc_chunk_align (struct grub_relocator *rel,
   grub_dprintf ("relocator", "relocators_size=%ld\n",
 		(unsigned long) rel->relocators_size);
 
-  if (chunk->src < chunk->target)
+  if (ctx.chunk->src < ctx.chunk->target)
     rel->relocators_size += grub_relocator_backward_size;
-  if (chunk->src > chunk->target)
+  if (ctx.chunk->src > ctx.chunk->target)
     rel->relocators_size += grub_relocator_forward_size;
 
   grub_dprintf ("relocator", "relocators_size=%ld\n",
 		(unsigned long) rel->relocators_size);
 
-  chunk->size = size;
-  chunk->next = rel->chunks;
-  rel->chunks = chunk;
+  ctx.chunk->size = size;
+  ctx.chunk->next = rel->chunks;
+  rel->chunks = ctx.chunk;
   grub_dprintf ("relocator", "cur = %p, next = %p\n", rel->chunks,
 		rel->chunks->next);
-  chunk->srcv = grub_map_memory (chunk->src, chunk->size);
-  *out = chunk;
+  ctx.chunk->srcv = grub_map_memory (ctx.chunk->src, ctx.chunk->size);
+  *out = ctx.chunk;
 #ifdef DEBUG_RELOCATOR
-  grub_memset (chunk->srcv, 0xfa, chunk->size);
+  grub_memset (ctx.chunk->srcv, 0xfa, ctx.chunk->size);
   grub_mm_check ();
 #endif
   return GRUB_ERR_NONE;
diff --git a/grub-core/loader/i386/bsd.c b/grub-core/loader/i386/bsd.c
index 6e024e4..871cf04 100644
--- a/grub-core/loader/i386/bsd.c
+++ b/grub-core/loader/i386/bsd.c
@@ -269,81 +269,93 @@ struct grub_e820_mmap
 #define GRUB_E820_NVS        4
 #define GRUB_E820_BADRAM     5
 
-static void
-generate_e820_mmap (grub_size_t *len, grub_size_t *cnt, void *buf)
+/* Context for generate_e820_mmap.  */
+struct generate_e820_mmap_ctx
 {
-  int count = 0;
-  struct grub_e820_mmap *mmap = buf;
+  int count;
+  struct grub_e820_mmap *mmap;
   struct grub_e820_mmap prev, cur;
+};
 
-  auto int NESTED_FUNC_ATTR hook (grub_uint64_t, grub_uint64_t,
-				  grub_memory_type_t);
-  int NESTED_FUNC_ATTR hook (grub_uint64_t addr, grub_uint64_t size,
-			     grub_memory_type_t type)
-    {
-      cur.addr = addr;
-      cur.size = size;
-      switch (type)
-	{
-	case GRUB_MEMORY_AVAILABLE:
-	  cur.type = GRUB_E820_RAM;
-	  break;
-
-	case GRUB_MEMORY_ACPI:
-	  cur.type = GRUB_E820_ACPI;
-	  break;
+/* Helper for generate_e820_mmap.  */
+static int
+generate_e820_mmap_iter (grub_uint64_t addr, grub_uint64_t size,
+			 grub_memory_type_t type, void *data)
+{
+  struct generate_e820_mmap_ctx *ctx = data;
 
-	case GRUB_MEMORY_NVS:
-	  cur.type = GRUB_E820_NVS;
-	  break;
+  ctx->cur.addr = addr;
+  ctx->cur.size = size;
+  switch (type)
+    {
+    case GRUB_MEMORY_AVAILABLE:
+      ctx->cur.type = GRUB_E820_RAM;
+      break;
+
+    case GRUB_MEMORY_ACPI:
+      ctx->cur.type = GRUB_E820_ACPI;
+      break;
+
+    case GRUB_MEMORY_NVS:
+      ctx->cur.type = GRUB_E820_NVS;
+      break;
+
+    default:
+    case GRUB_MEMORY_CODE:
+    case GRUB_MEMORY_RESERVED:
+      ctx->cur.type = GRUB_E820_RESERVED;
+      break;
+    }
 
-	default:
-	case GRUB_MEMORY_CODE:
-	case GRUB_MEMORY_RESERVED:
-	  cur.type = GRUB_E820_RESERVED;
-	  break;
-	}
+  /* Merge regions if possible. */
+  if (ctx->count && ctx->cur.type == ctx->prev.type
+      && ctx->cur.addr == ctx->prev.addr + ctx->prev.size)
+    {
+      ctx->prev.size += ctx->cur.size;
+      if (ctx->mmap)
+	ctx->mmap[-1] = ctx->prev;
+    }
+  else
+    {
+      if (ctx->mmap)
+	*ctx->mmap++ = ctx->cur;
+      ctx->prev = ctx->cur;
+      ctx->count++;
+    }
 
-      /* Merge regions if possible. */
-      if (count && cur.type == prev.type && cur.addr == prev.addr + prev.size)
-	{
-	  prev.size += cur.size;
-	  if (mmap)
-	    mmap[-1] = prev;
-	}
-      else
+  if (kernel_type == KERNEL_TYPE_OPENBSD && ctx->prev.addr < 0x100000
+      && ctx->prev.addr + ctx->prev.size > 0x100000)
+    {
+      ctx->cur.addr = 0x100000;
+      ctx->cur.size = ctx->prev.addr + ctx->prev.size - 0x100000;
+      ctx->cur.type = ctx->prev.type;
+      ctx->prev.size = 0x100000 - ctx->prev.addr;
+      if (ctx->mmap)
 	{
-	  if (mmap)
-	    *mmap++ = cur;
-	  prev = cur;
-	  count++;
+	  ctx->mmap[-1] = ctx->prev;
+	  ctx->mmap[0] = ctx->cur;
+	  ctx->mmap++;
 	}
+      ctx->prev = ctx->cur;
+      ctx->count++;
+    }
 
-      if (kernel_type == KERNEL_TYPE_OPENBSD && prev.addr < 0x100000
-	  && prev.addr + prev.size > 0x100000)
-	{
-	  cur.addr = 0x100000;
-	  cur.size = prev.addr + prev.size - 0x100000;
-	  cur.type = prev.type;
-	  prev.size = 0x100000 - prev.addr;
-	  if (mmap)
-	    {
-	      mmap[-1] = prev;
-	      mmap[0] = cur;
-	      mmap++;
-	    }
-	  prev = cur;
-	  count++;
-	}
+  return 0;
+}
 
-      return 0;
-    }
+static void
+generate_e820_mmap (grub_size_t *len, grub_size_t *cnt, void *buf)
+{
+  struct generate_e820_mmap_ctx ctx = {
+    .count = 0,
+    .mmap = buf
+  };
 
-  grub_mmap_iterate (hook);
+  grub_mmap_iterate (generate_e820_mmap_iter, &ctx);
 
   if (len)
-    *len = count * sizeof (struct grub_e820_mmap);
-  *cnt = count;
+    *len = ctx.count * sizeof (struct grub_e820_mmap);
+  *cnt = ctx.count;
 
   return;
 }
diff --git a/grub-core/loader/i386/linux.c b/grub-core/loader/i386/linux.c
index fc0ebe7..41357a5 100644
--- a/grub-core/loader/i386/linux.c
+++ b/grub-core/loader/i386/linux.c
@@ -150,23 +150,25 @@ find_efi_mmap_size (void)
 
 #endif
 
+/* Helper for find_mmap_size.  */
+static int
+count_hook (grub_uint64_t addr __attribute__ ((unused)),
+	    grub_uint64_t size __attribute__ ((unused)),
+	    grub_memory_type_t type __attribute__ ((unused)), void *data)
+{
+  grub_size_t *count = data;
+
+  (*count)++;
+  return 0;
+}
+
 /* Find the optimal number of pages for the memory map. */
 static grub_size_t
 find_mmap_size (void)
 {
   grub_size_t count = 0, mmap_size;
 
-  auto int NESTED_FUNC_ATTR hook (grub_uint64_t, grub_uint64_t,
-				  grub_memory_type_t);
-  int NESTED_FUNC_ATTR hook (grub_uint64_t addr __attribute__ ((unused)),
-			     grub_uint64_t size __attribute__ ((unused)),
-			     grub_memory_type_t type __attribute__ ((unused)))
-    {
-      count++;
-      return 0;
-    }
-
-  grub_mmap_iterate (hook);
+  grub_mmap_iterate (count_hook, &count);
 
   mmap_size = count * sizeof (struct grub_e820_mmap);
 
@@ -372,17 +374,96 @@ grub_linux_setup_video (struct linux_kernel_params *params)
   return GRUB_ERR_NONE;
 }
 
+/* Context for grub_linux_boot.  */
+struct grub_linux_boot_ctx
+{
+  grub_addr_t real_mode_target;
+  grub_size_t real_size;
+  struct linux_kernel_params *params;
+  int e820_num;
+};
+
+/* Helper for grub_linux_boot.  */
+static int
+grub_linux_boot_mmap_find (grub_uint64_t addr, grub_uint64_t size,
+			   grub_memory_type_t type, void *data)
+{
+  struct grub_linux_boot_ctx *ctx = data;
+
+  /* We must put real mode code in the traditional space.  */
+  if (type != GRUB_MEMORY_AVAILABLE || addr > 0x90000)
+    return 0;
+
+  if (addr + size < 0x10000)
+    return 0;
+
+  if (addr < 0x10000)
+    {
+      size += addr - 0x10000;
+      addr = 0x10000;
+    }
+
+  if (addr + size > 0x90000)
+    size = 0x90000 - addr;
+
+  if (ctx->real_size + efi_mmap_size > size)
+    return 0;
+
+  grub_dprintf ("linux", "addr = %lx, size = %x, need_size = %x\n",
+		(unsigned long) addr,
+		(unsigned) size,
+		(unsigned) (ctx->real_size + efi_mmap_size));
+  ctx->real_mode_target = ((addr + size) - (ctx->real_size + efi_mmap_size));
+  return 1;
+}
+
+static int
+grub_linux_boot_mmap_fill (grub_uint64_t addr, grub_uint64_t size,
+			   grub_memory_type_t type, void *data)
+{
+  struct grub_linux_boot_ctx *ctx = data;
+
+  grub_uint32_t e820_type;
+  switch (type)
+    {
+    case GRUB_MEMORY_AVAILABLE:
+      e820_type = GRUB_E820_RAM;
+      break;
+
+    case GRUB_MEMORY_ACPI:
+      e820_type = GRUB_E820_ACPI;
+      break;
+
+    case GRUB_MEMORY_NVS:
+      e820_type = GRUB_E820_NVS;
+      break;
+
+    case GRUB_MEMORY_BADRAM:
+      e820_type = GRUB_E820_BADRAM;
+      break;
+
+    default:
+      e820_type = GRUB_E820_RESERVED;
+    }
+  if (grub_e820_add_region (ctx->params->e820_map, &ctx->e820_num,
+			    addr, size, e820_type))
+    return 1;
+
+  return 0;
+}
+
 static grub_err_t
 grub_linux_boot (void)
 {
-  int e820_num;
   grub_err_t err = 0;
   const char *modevar;
   char *tmp;
   struct grub_relocator32_state state;
   void *real_mode_mem;
-  grub_addr_t real_mode_target = 0;
-  grub_size_t real_size, mmap_size;
+  struct grub_linux_boot_ctx ctx = {
+    .real_mode_target = 0
+  };
+  grub_size_t mmap_size;
   grub_size_t cl_offset;
 
 #ifdef GRUB_MACHINE_IEEE1275
@@ -484,7 +565,7 @@ grub_linux_boot (void)
   if (cl_offset < ((grub_size_t) linux_params.setup_sects << GRUB_DISK_SECTOR_BITS))
     cl_offset = ALIGN_UP ((grub_size_t) (linux_params.setup_sects
 					 << GRUB_DISK_SECTOR_BITS), 4096);
-  real_size = ALIGN_UP (cl_offset + maximal_cmdline_size, 4096);
+  ctx.real_size = ALIGN_UP (cl_offset + maximal_cmdline_size, 4096);
 
 #ifdef GRUB_MACHINE_EFI
   efi_mmap_size = find_efi_mmap_size ();
@@ -493,118 +574,51 @@ grub_linux_boot (void)
 #endif
 
   grub_dprintf ("linux", "real_size = %x, mmap_size = %x\n",
-		(unsigned) real_size, (unsigned) mmap_size);
-
-  auto int NESTED_FUNC_ATTR hook (grub_uint64_t, grub_uint64_t,
-				  grub_memory_type_t);
-  int NESTED_FUNC_ATTR hook (grub_uint64_t addr, grub_uint64_t size,
-			     grub_memory_type_t type)
-    {
-      /* We must put real mode code in the traditional space.  */
-      if (type != GRUB_MEMORY_AVAILABLE || addr > 0x90000)
-	return 0;
-
-      if (addr + size < 0x10000)
-	return 0;
-
-      if (addr < 0x10000)
-	{
-	  size += addr - 0x10000;
-	  addr = 0x10000;
-	}
+		(unsigned) ctx.real_size, (unsigned) mmap_size);
 
-      if (addr + size > 0x90000)
-	size = 0x90000 - addr;
-
-      if (real_size + efi_mmap_size > size)
-	return 0;
-
-      grub_dprintf ("linux", "addr = %lx, size = %x, need_size = %x\n",
-		    (unsigned long) addr,
-		    (unsigned) size,
-		    (unsigned) (real_size + efi_mmap_size));
-      real_mode_target = ((addr + size) - (real_size + efi_mmap_size));
-      return 1;
-    }
 #ifdef GRUB_MACHINE_EFI
-  grub_efi_mmap_iterate (hook, 1);
-  if (! real_mode_target)
-    grub_efi_mmap_iterate (hook, 0);
+  grub_efi_mmap_iterate (grub_linux_boot_mmap_find, &ctx, 1);
+  if (! ctx.real_mode_target)
+    grub_efi_mmap_iterate (grub_linux_boot_mmap_find, &ctx, 0);
 #else
-  grub_mmap_iterate (hook);
+  grub_mmap_iterate (grub_linux_boot_mmap_find, &ctx);
 #endif
   grub_dprintf ("linux", "real_mode_target = %lx, real_size = %x, efi_mmap_size = %x\n",
-                (unsigned long) real_mode_target,
-		(unsigned) real_size,
+                (unsigned long) ctx.real_mode_target,
+		(unsigned) ctx.real_size,
 		(unsigned) efi_mmap_size);
 
-  if (! real_mode_target)
+  if (! ctx.real_mode_target)
     return grub_error (GRUB_ERR_OUT_OF_MEMORY, "cannot allocate real mode pages");
 
   {
     grub_relocator_chunk_t ch;
     err = grub_relocator_alloc_chunk_addr (relocator, &ch,
-					   real_mode_target,
-					   (real_size + efi_mmap_size));
+					   ctx.real_mode_target,
+					   (ctx.real_size + efi_mmap_size));
     if (err)
      return err;
     real_mode_mem = get_virtual_current_address (ch);
   }
-  efi_mmap_buf = (grub_uint8_t *) real_mode_mem + real_size;
+  efi_mmap_buf = (grub_uint8_t *) real_mode_mem + ctx.real_size;
 
   grub_dprintf ("linux", "real_mode_mem = %lx\n",
                 (unsigned long) real_mode_mem);
 
-  struct linux_kernel_params *params;
-
-  params = real_mode_mem;
+  ctx.params = real_mode_mem;
 
-  *params = linux_params;
-  params->cmd_line_ptr = real_mode_target + cl_offset;
-  grub_memcpy ((char *) params + cl_offset, linux_cmdline,
+  *ctx.params = linux_params;
+  ctx.params->cmd_line_ptr = ctx.real_mode_target + cl_offset;
+  grub_memcpy ((char *) ctx.params + cl_offset, linux_cmdline,
 	       maximal_cmdline_size);
 
   grub_dprintf ("linux", "code32_start = %x\n",
-		(unsigned) params->code32_start);
-
-  auto int NESTED_FUNC_ATTR hook_fill (grub_uint64_t, grub_uint64_t,
-				  grub_memory_type_t);
-  int NESTED_FUNC_ATTR hook_fill (grub_uint64_t addr, grub_uint64_t size, 
-				  grub_memory_type_t type)
-    {
-      grub_uint32_t e820_type;
-      switch (type)
-        {
-        case GRUB_MEMORY_AVAILABLE:
-	  e820_type = GRUB_E820_RAM;
-	  break;
-
-        case GRUB_MEMORY_ACPI:
-	  e820_type = GRUB_E820_ACPI;
-	  break;
-
-        case GRUB_MEMORY_NVS:
-	  e820_type = GRUB_E820_NVS;
-	  break;
-
-        case GRUB_MEMORY_BADRAM:
-	  e820_type = GRUB_E820_BADRAM;
-	  break;
-
-        default:
-          e820_type = GRUB_E820_RESERVED;
-        }
-      if (grub_e820_add_region (params->e820_map, &e820_num,
-				addr, size, e820_type))
-	return 1;
-
-      return 0;
-    }
+		(unsigned) ctx.params->code32_start);
 
-  e820_num = 0;
-  if (grub_mmap_iterate (hook_fill))
+  ctx.e820_num = 0;
+  if (grub_mmap_iterate (grub_linux_boot_mmap_fill, &ctx))
     return grub_errno;
-  params->mmap_size = e820_num;
+  ctx.params->mmap_size = ctx.e820_num;
 
 #ifdef GRUB_MACHINE_EFI
   {
@@ -617,33 +631,33 @@ grub_linux_boot (void)
       return err;
     
     /* Note that no boot services are available from here.  */
-    efi_mmap_target = real_mode_target 
+    efi_mmap_target = ctx.real_mode_target 
       + ((grub_uint8_t *) efi_mmap_buf - (grub_uint8_t *) real_mode_mem);
     /* Pass EFI parameters.  */
-    if (grub_le_to_cpu16 (params->version) >= 0x0208)
+    if (grub_le_to_cpu16 (ctx.params->version) >= 0x0208)
       {
-	params->v0208.efi_mem_desc_size = efi_desc_size;
-	params->v0208.efi_mem_desc_version = efi_desc_version;
-	params->v0208.efi_mmap = efi_mmap_target;
-	params->v0208.efi_mmap_size = efi_mmap_size;
+	ctx.params->v0208.efi_mem_desc_size = efi_desc_size;
+	ctx.params->v0208.efi_mem_desc_version = efi_desc_version;
+	ctx.params->v0208.efi_mmap = efi_mmap_target;
+	ctx.params->v0208.efi_mmap_size = efi_mmap_size;
 
 #ifdef __x86_64__
-	params->v0208.efi_mmap_hi = (efi_mmap_target >> 32);
+	ctx.params->v0208.efi_mmap_hi = (efi_mmap_target >> 32);
 #endif
       }
-    else if (grub_le_to_cpu16 (params->version) >= 0x0206)
+    else if (grub_le_to_cpu16 (ctx.params->version) >= 0x0206)
       {
-	params->v0206.efi_mem_desc_size = efi_desc_size;
-	params->v0206.efi_mem_desc_version = efi_desc_version;
-	params->v0206.efi_mmap = efi_mmap_target;
-	params->v0206.efi_mmap_size = efi_mmap_size;
+	ctx.params->v0206.efi_mem_desc_size = efi_desc_size;
+	ctx.params->v0206.efi_mem_desc_version = efi_desc_version;
+	ctx.params->v0206.efi_mmap = efi_mmap_target;
+	ctx.params->v0206.efi_mmap_size = efi_mmap_size;
       }
-    else if (grub_le_to_cpu16 (params->version) >= 0x0204)
+    else if (grub_le_to_cpu16 (ctx.params->version) >= 0x0204)
       {
-	params->v0204.efi_mem_desc_size = efi_desc_size;
-	params->v0204.efi_mem_desc_version = efi_desc_version;
-	params->v0204.efi_mmap = efi_mmap_target;
-	params->v0204.efi_mmap_size = efi_mmap_size;
+	ctx.params->v0204.efi_mem_desc_size = efi_desc_size;
+	ctx.params->v0204.efi_mem_desc_version = efi_desc_version;
+	ctx.params->v0204.efi_mmap = efi_mmap_target;
+	ctx.params->v0204.efi_mmap_size = efi_mmap_size;
       }
   }
 #endif
@@ -651,9 +665,9 @@ grub_linux_boot (void)
   /* FIXME.  */
   /*  asm volatile ("lidt %0" : : "m" (idt_desc)); */
   state.ebp = state.edi = state.ebx = 0;
-  state.esi = real_mode_target;
-  state.esp = real_mode_target;
-  state.eip = params->code32_start;
+  state.esi = ctx.real_mode_target;
+  state.esp = ctx.real_mode_target;
+  state.eip = ctx.params->code32_start;
   return grub_relocator32_boot (relocator, state, 0);
 }
 
diff --git a/grub-core/loader/i386/multiboot_mbi.c b/grub-core/loader/i386/multiboot_mbi.c
index 8fc40d7..18fd367 100644
--- a/grub-core/loader/i386/multiboot_mbi.c
+++ b/grub-core/loader/i386/multiboot_mbi.c
@@ -224,48 +224,50 @@ grub_multiboot_get_mbi_size (void)
   return ret;
 }
 
+/* Helper for grub_fill_multiboot_mmap.  */
+static int
+grub_fill_multiboot_mmap_iter (grub_uint64_t addr, grub_uint64_t size,
+			       grub_memory_type_t type, void *data)
+{
+  struct multiboot_mmap_entry **mmap_entry = data;
+
+  (*mmap_entry)->addr = addr;
+  (*mmap_entry)->len = size;
+  switch (type)
+    {
+    case GRUB_MEMORY_AVAILABLE:
+      (*mmap_entry)->type = MULTIBOOT_MEMORY_AVAILABLE;
+      break;
+
+    case GRUB_MEMORY_ACPI:
+      (*mmap_entry)->type = MULTIBOOT_MEMORY_ACPI_RECLAIMABLE;
+      break;
+
+    case GRUB_MEMORY_NVS:
+      (*mmap_entry)->type = MULTIBOOT_MEMORY_NVS;
+      break;
+
+    case GRUB_MEMORY_BADRAM:
+      (*mmap_entry)->type = MULTIBOOT_MEMORY_BADRAM;
+      break;
+      
+    default:
+      (*mmap_entry)->type = MULTIBOOT_MEMORY_RESERVED;
+      break;
+    }
+  (*mmap_entry)->size = sizeof (struct multiboot_mmap_entry) - sizeof ((*mmap_entry)->size);
+  (*mmap_entry)++;
+
+  return 0;
+}
+
 /* Fill previously allocated Multiboot mmap.  */
 static void
 grub_fill_multiboot_mmap (struct multiboot_mmap_entry *first_entry)
 {
   struct multiboot_mmap_entry *mmap_entry = (struct multiboot_mmap_entry *) first_entry;
 
-  auto int NESTED_FUNC_ATTR hook (grub_uint64_t, grub_uint64_t,
-				  grub_memory_type_t);
-  int NESTED_FUNC_ATTR hook (grub_uint64_t addr, grub_uint64_t size, 
-			     grub_memory_type_t type)
-    {
-      mmap_entry->addr = addr;
-      mmap_entry->len = size;
-      switch (type)
-	{
-	case GRUB_MEMORY_AVAILABLE:
- 	  mmap_entry->type = MULTIBOOT_MEMORY_AVAILABLE;
- 	  break;
-
-	case GRUB_MEMORY_ACPI:
- 	  mmap_entry->type = MULTIBOOT_MEMORY_ACPI_RECLAIMABLE;
- 	  break;
-
-	case GRUB_MEMORY_NVS:
- 	  mmap_entry->type = MULTIBOOT_MEMORY_NVS;
- 	  break;
-
-	case GRUB_MEMORY_BADRAM:
- 	  mmap_entry->type = MULTIBOOT_MEMORY_BADRAM;
- 	  break;
-	  
- 	default:
- 	  mmap_entry->type = MULTIBOOT_MEMORY_RESERVED;
- 	  break;
- 	}
-      mmap_entry->size = sizeof (struct multiboot_mmap_entry) - sizeof (mmap_entry->size);
-      mmap_entry++;
-
-      return 0;
-    }
-
-  grub_mmap_iterate (hook);
+  grub_mmap_iterate (grub_fill_multiboot_mmap_iter, &mmap_entry);
 }
 
 #if GRUB_MACHINE_HAS_VBE || GRUB_MACHINE_HAS_VGA_TEXT
diff --git a/grub-core/loader/multiboot.c b/grub-core/loader/multiboot.c
index fcdf5ff..496e54c 100644
--- a/grub-core/loader/multiboot.c
+++ b/grub-core/loader/multiboot.c
@@ -63,6 +63,18 @@ static int console_required;
 static grub_dl_t my_mod;
 
 
+/* Helper for grub_get_multiboot_mmap_count.  */
+static int
+count_hook (grub_uint64_t addr __attribute__ ((unused)),
+	    grub_uint64_t size __attribute__ ((unused)),
+	    grub_memory_type_t type __attribute__ ((unused)), void *data)
+{
+  grub_size_t *count = data;
+
+  (*count)++;
+  return 0;
+}
+
 /* Return the length of the Multiboot mmap that will be needed to allocate
    our platform's map.  */
 grub_uint32_t
@@ -70,16 +82,7 @@ grub_get_multiboot_mmap_count (void)
 {
   grub_size_t count = 0;
 
-  auto int NESTED_FUNC_ATTR hook (grub_uint64_t, grub_uint64_t, grub_uint32_t);
-  int NESTED_FUNC_ATTR hook (grub_uint64_t addr __attribute__ ((unused)),
-			     grub_uint64_t size __attribute__ ((unused)),
-			     grub_memory_type_t type __attribute__ ((unused)))
-    {
-      count++;
-      return 0;
-    }
-
-  grub_mmap_iterate (hook);
+  grub_mmap_iterate (count_hook, &count);
 
   return count;
 }
diff --git a/grub-core/loader/multiboot_mbi2.c b/grub-core/loader/multiboot_mbi2.c
index a48f020..900793a 100644
--- a/grub-core/loader/multiboot_mbi2.c
+++ b/grub-core/loader/multiboot_mbi2.c
@@ -322,45 +322,47 @@ grub_multiboot_get_mbi_size (void)
     + sizeof (struct multiboot_tag_apm) + MULTIBOOT_TAG_ALIGN - 1;
 }
 
-/* Fill previously allocated Multiboot mmap.  */
-static void
-grub_fill_multiboot_mmap (struct multiboot_tag_mmap *tag)
+/* Helper for grub_fill_multiboot_mmap.  */
+static int
+grub_fill_multiboot_mmap_iter (grub_uint64_t addr, grub_uint64_t size,
+			       grub_memory_type_t type, void *data)
 {
-  struct multiboot_mmap_entry *mmap_entry = tag->entries;
+  struct multiboot_mmap_entry **mmap_entry = data;
 
-  auto int NESTED_FUNC_ATTR hook (grub_uint64_t, grub_uint64_t,
-				  grub_memory_type_t);
-  int NESTED_FUNC_ATTR hook (grub_uint64_t addr, grub_uint64_t size,
-			     grub_memory_type_t type)
+  (*mmap_entry)->addr = addr;
+  (*mmap_entry)->len = size;
+  switch (type)
     {
-      mmap_entry->addr = addr;
-      mmap_entry->len = size;
-      switch (type)
-	{
-	case GRUB_MEMORY_AVAILABLE:
- 	  mmap_entry->type = MULTIBOOT_MEMORY_AVAILABLE;
- 	  break;
-
-	case GRUB_MEMORY_ACPI:
- 	  mmap_entry->type = MULTIBOOT_MEMORY_ACPI_RECLAIMABLE;
- 	  break;
+    case GRUB_MEMORY_AVAILABLE:
+      (*mmap_entry)->type = MULTIBOOT_MEMORY_AVAILABLE;
+      break;
 
-	case GRUB_MEMORY_NVS:
- 	  mmap_entry->type = MULTIBOOT_MEMORY_NVS;
- 	  break;
+    case GRUB_MEMORY_ACPI:
+      (*mmap_entry)->type = MULTIBOOT_MEMORY_ACPI_RECLAIMABLE;
+      break;
 
-	case GRUB_MEMORY_BADRAM:
- 	  mmap_entry->type = MULTIBOOT_MEMORY_BADRAM;
- 	  break;
+    case GRUB_MEMORY_NVS:
+      (*mmap_entry)->type = MULTIBOOT_MEMORY_NVS;
+      break;
 
- 	default:
- 	  mmap_entry->type = MULTIBOOT_MEMORY_RESERVED;
- 	  break;
- 	}
-      mmap_entry++;
+    case GRUB_MEMORY_BADRAM:
+      (*mmap_entry)->type = MULTIBOOT_MEMORY_BADRAM;
+      break;
 
-      return 0;
+    default:
+      (*mmap_entry)->type = MULTIBOOT_MEMORY_RESERVED;
+      break;
     }
+  (*mmap_entry)++;
+
+  return 0;
+}
+
+/* Fill previously allocated Multiboot mmap.  */
+static void
+grub_fill_multiboot_mmap (struct multiboot_tag_mmap *tag)
+{
+  struct multiboot_mmap_entry *mmap_entry = tag->entries;
 
   tag->type = MULTIBOOT_TAG_TYPE_MMAP;
   tag->size = sizeof (struct multiboot_tag_mmap)
@@ -368,7 +370,7 @@ grub_fill_multiboot_mmap (struct multiboot_tag_mmap *tag)
   tag->entry_size = sizeof (struct multiboot_mmap_entry);
   tag->entry_version = 0;
 
-  grub_mmap_iterate (hook);
+  grub_mmap_iterate (grub_fill_multiboot_mmap_iter, &mmap_entry);
 }
 
 #if defined (GRUB_MACHINE_PCBIOS)
diff --git a/grub-core/loader/powerpc/ieee1275/linux.c b/grub-core/loader/powerpc/ieee1275/linux.c
index 70e288c..b150904 100644
--- a/grub-core/loader/powerpc/ieee1275/linux.c
+++ b/grub-core/loader/powerpc/ieee1275/linux.c
@@ -51,49 +51,51 @@ static char *linux_args;
 typedef void (*kernel_entry_t) (void *, unsigned long, int (void *),
 				unsigned long, unsigned long);
 
+/* Helper for grub_linux_claimmap_iterate.  */
+static int
+alloc_mem (grub_uint64_t addr, grub_uint64_t len, grub_memory_type_t type,
+	   void *data)
+{
+  grub_addr_t *found_addr = data;
+
+  grub_uint64_t end = addr + len;
+  addr = ALIGN_UP (addr, align);
+  target = ALIGN_UP (target, align);
+
+  /* Target above the memory chunk.  */
+  if (type != GRUB_MEMORY_AVAILABLE || target > end)
+    return 0;
+
+  /* Target inside the memory chunk.  */
+  if (target >= addr && target < end && size <= end - target)
+    {
+      if (grub_claimmap (target, size) == GRUB_ERR_NONE)
+	{
+	  *found_addr = target;
+	  return 1;
+	}
+      grub_print_error ();
+    }
+  /* Target below the memory chunk.  */
+  if (target < addr && addr + size <= end)
+    {
+      if (grub_claimmap (addr, size) == GRUB_ERR_NONE)
+	{
+	  *found_addr = addr;
+	  return 1;
+	}
+      grub_print_error ();
+    }
+  return 0;
+}
+
 static grub_addr_t
 grub_linux_claimmap_iterate (grub_addr_t target, grub_size_t size,
 			     grub_size_t align)
 {
   grub_addr_t found_addr = (grub_addr_t) -1;
 
-  auto int NESTED_FUNC_ATTR alloc_mem (grub_uint64_t addr, grub_uint64_t len,
-				       grub_memory_type_t type);
-  int NESTED_FUNC_ATTR alloc_mem (grub_uint64_t addr, grub_uint64_t len,
-				  grub_memory_type_t type)
-  {
-    grub_uint64_t end = addr + len;
-    addr = ALIGN_UP (addr, align);
-    target = ALIGN_UP (target, align);
-
-    /* Target above the memory chunk.  */
-    if (type != GRUB_MEMORY_AVAILABLE || target > end)
-      return 0;
-
-    /* Target inside the memory chunk.  */
-    if (target >= addr && target < end && size <= end - target)
-      {
-	if (grub_claimmap (target, size) == GRUB_ERR_NONE)
-	  {
-	    found_addr = target;
-	    return 1;
-	  }
-	grub_print_error ();
-      }
-    /* Target below the memory chunk.  */
-    if (target < addr && addr + size <= end)
-      {
-	if (grub_claimmap (addr, size) == GRUB_ERR_NONE)
-	  {
-	    found_addr = addr;
-	    return 1;
-	  }
-	grub_print_error ();
-      }
-    return 0;
-  }
-
-  grub_machine_mmap_iterate (alloc_mem);
+  grub_machine_mmap_iterate (alloc_mem, &found_addr);
 
   return found_addr;
 }
diff --git a/grub-core/loader/sparc64/ieee1275/linux.c b/grub-core/loader/sparc64/ieee1275/linux.c
index 06d1df6..a485284 100644
--- a/grub-core/loader/sparc64/ieee1275/linux.c
+++ b/grub-core/loader/sparc64/ieee1275/linux.c
@@ -180,63 +180,64 @@ grub_linux_unload (void)
 
 #define FOUR_MB	(4 * 1024 * 1024)
 
-static grub_addr_t
-alloc_phys (grub_addr_t size)
+/* Helper for alloc_phys.  */
+static int
+alloc_phys_choose (grub_uint64_t addr, grub_uint64_t len,
+		   grub_memory_type_t type, void *data)
 {
-  grub_addr_t ret = (grub_addr_t) -1;
+  grub_addr_t *ret = data;
+  grub_addr_t end = addr + len;
 
-  auto int NESTED_FUNC_ATTR choose (grub_uint64_t addr, grub_uint64_t len,
-				    grub_memory_type_t type);
-  int NESTED_FUNC_ATTR choose (grub_uint64_t addr, grub_uint64_t len,
-			       grub_memory_type_t type)
-  {
-    grub_addr_t end = addr + len;
+  if (type != 1)
+    return 0;
 
-    if (type != 1)
-      return 0;
+  addr = ALIGN_UP (addr, FOUR_MB);
+  if (addr + size >= end)
+    return 0;
 
-    addr = ALIGN_UP (addr, FOUR_MB);
-    if (addr + size >= end)
-      return 0;
+  if (addr >= grub_phys_start && addr < grub_phys_end)
+    {
+      addr = ALIGN_UP (grub_phys_end, FOUR_MB);
+      if (addr + size >= end)
+	return 0;
+    }
+  if ((addr + size) >= grub_phys_start
+      && (addr + size) < grub_phys_end)
+    {
+      addr = ALIGN_UP (grub_phys_end, FOUR_MB);
+      if (addr + size >= end)
+	return 0;
+    }
 
-    if (addr >= grub_phys_start && addr < grub_phys_end)
-      {
-	addr = ALIGN_UP (grub_phys_end, FOUR_MB);
-	if (addr + size >= end)
-	  return 0;
-      }
-    if ((addr + size) >= grub_phys_start
-	&& (addr + size) < grub_phys_end)
-      {
-	addr = ALIGN_UP (grub_phys_end, FOUR_MB);
-	if (addr + size >= end)
-	  return 0;
-      }
-
-    if (loaded)
-      {
-	grub_addr_t linux_end = ALIGN_UP (linux_paddr + linux_size, FOUR_MB);
-
-	if (addr >= linux_paddr && addr < linux_end)
-	  {
-	    addr = linux_end;
-	    if (addr + size >= end)
-	      return 0;
-	  }
-	if ((addr + size) >= linux_paddr
-	    && (addr + size) < linux_end)
-	  {
-	    addr = linux_end;
-	    if (addr + size >= end)
-	      return 0;
-	  }
-      }
-
-    ret = addr;
-    return 1;
-  }
-
-  grub_machine_mmap_iterate (choose);
+  if (loaded)
+    {
+      grub_addr_t linux_end = ALIGN_UP (linux_paddr + linux_size, FOUR_MB);
+
+      if (addr >= linux_paddr && addr < linux_end)
+	{
+	  addr = linux_end;
+	  if (addr + size >= end)
+	    return 0;
+	}
+      if ((addr + size) >= linux_paddr
+	  && (addr + size) < linux_end)
+	{
+	  addr = linux_end;
+	  if (addr + size >= end)
+	    return 0;
+	}
+    }
+
+  *ret = addr;
+  return 1;
+}
+
+static grub_addr_t
+alloc_phys (grub_addr_t size)
+{
+  grub_addr_t ret = (grub_addr_t) -1;
+
+  grub_machine_mmap_iterate (alloc_phys_choose, &ret);
 
   return ret;
 }
@@ -454,21 +455,23 @@ grub_cmd_initrd (grub_command_t cmd __attribute__ ((unused)),
   return grub_errno;
 }
 
-static void
-determine_phys_base (void)
+/* Helper for determine_phys_base.  */
+static int
+get_physbase (grub_uint64_t addr, grub_uint64_t len __attribute__ ((unused)),
+	      grub_uint32_t type, void *data __attribute__ ((unused)))
 {
-  auto int NESTED_FUNC_ATTR get_physbase (grub_uint64_t addr, grub_uint64_t len __attribute__((unused)), grub_uint32_t type);
-  int NESTED_FUNC_ATTR get_physbase (grub_uint64_t addr, grub_uint64_t len __attribute__((unused)), grub_uint32_t type)
-  {
-    if (type != 1)
-      return 0;
-    if (addr < phys_base)
-      phys_base = addr;
+  if (type != 1)
     return 0;
-  }
+  if (addr < phys_base)
+    phys_base = addr;
+  return 0;
+}
 
+static void
+determine_phys_base (void)
+{
   phys_base = ~(grub_uint64_t) 0;
-  grub_machine_mmap_iterate (get_physbase);
+  grub_machine_mmap_iterate (get_physbase, NULL);
 }
 
 static void
diff --git a/grub-core/mmap/efi/mmap.c b/grub-core/mmap/efi/mmap.c
index c71adad..4f17c8b 100644
--- a/grub-core/mmap/efi/mmap.c
+++ b/grub-core/mmap/efi/mmap.c
@@ -29,7 +29,8 @@
   ((grub_efi_memory_descriptor_t *) ((char *) (desc) + (size)))
 
 grub_err_t
-grub_efi_mmap_iterate (grub_memory_hook_t hook, int avoid_efi_boot_services)
+grub_efi_mmap_iterate (grub_memory_hook_t hook, void *hook_data,
+		       int avoid_efi_boot_services)
 {
   grub_efi_uintn_t mmap_size = 0;
   grub_efi_memory_descriptor_t *map_buf = 0;
@@ -69,17 +70,17 @@ grub_efi_mmap_iterate (grub_memory_hook_t hook, int avoid_efi_boot_services)
 	  if (!avoid_efi_boot_services)
 	    {
 	      hook (desc->physical_start, desc->num_pages * 4096,
-		    GRUB_MEMORY_AVAILABLE);
+		    GRUB_MEMORY_AVAILABLE, hook_data);
 	      break;
 	    }
 	case GRUB_EFI_RUNTIME_SERVICES_CODE:
 	  hook (desc->physical_start, desc->num_pages * 4096,
-		GRUB_MEMORY_CODE);
+		GRUB_MEMORY_CODE, hook_data);
 	  break;
 
 	case GRUB_EFI_UNUSABLE_MEMORY:
 	  hook (desc->physical_start, desc->num_pages * 4096,
-		GRUB_MEMORY_BADRAM);
+		GRUB_MEMORY_BADRAM, hook_data);
 	  break;
 
 	default:
@@ -90,7 +91,7 @@ grub_efi_mmap_iterate (grub_memory_hook_t hook, int avoid_efi_boot_services)
 	  if (!avoid_efi_boot_services)
 	    {
 	      hook (desc->physical_start, desc->num_pages * 4096,
-		    GRUB_MEMORY_AVAILABLE);
+		    GRUB_MEMORY_AVAILABLE, hook_data);
 	      break;
 	    }
 	case GRUB_EFI_RESERVED_MEMORY_TYPE:
@@ -99,24 +100,24 @@ grub_efi_mmap_iterate (grub_memory_hook_t hook, int avoid_efi_boot_services)
 	case GRUB_EFI_MEMORY_MAPPED_IO_PORT_SPACE:
 	case GRUB_EFI_PAL_CODE:
 	  hook (desc->physical_start, desc->num_pages * 4096,
-		GRUB_MEMORY_RESERVED);
+		GRUB_MEMORY_RESERVED, hook_data);
 	  break;
 
 	case GRUB_EFI_LOADER_CODE:
 	case GRUB_EFI_LOADER_DATA:
 	case GRUB_EFI_CONVENTIONAL_MEMORY:
 	  hook (desc->physical_start, desc->num_pages * 4096,
-		GRUB_MEMORY_AVAILABLE);
+		GRUB_MEMORY_AVAILABLE, hook_data);
 	  break;
 
 	case GRUB_EFI_ACPI_RECLAIM_MEMORY:
 	  hook (desc->physical_start, desc->num_pages * 4096,
-		GRUB_MEMORY_ACPI);
+		GRUB_MEMORY_ACPI, hook_data);
 	  break;
 
 	case GRUB_EFI_ACPI_MEMORY_NVS:
 	  hook (desc->physical_start, desc->num_pages * 4096,
-		GRUB_MEMORY_NVS);
+		GRUB_MEMORY_NVS, hook_data);
 	  break;
 	}
     }
@@ -125,9 +126,9 @@ grub_efi_mmap_iterate (grub_memory_hook_t hook, int avoid_efi_boot_services)
 }
 
 grub_err_t
-grub_machine_mmap_iterate (grub_memory_hook_t hook)
+grub_machine_mmap_iterate (grub_memory_hook_t hook, void *hook_data)
 {
-  return grub_efi_mmap_iterate (hook, 0);
+  return grub_efi_mmap_iterate (hook, hook_data, 0);
 }
 
 static inline grub_efi_memory_type_t
diff --git a/grub-core/mmap/i386/mmap.c b/grub-core/mmap/i386/mmap.c
index 648a7df..ac45f70 100644
--- a/grub-core/mmap/i386/mmap.c
+++ b/grub-core/mmap/i386/mmap.c
@@ -27,34 +27,48 @@
 
 #ifndef GRUB_MMAP_REGISTER_BY_FIRMWARE
 
+/* Context for grub_mmap_malign_and_register.  */
+struct grub_mmap_malign_and_register_ctx
+{
+  grub_uint64_t align, size, highestlow;
+};
+
+/* Helper for grub_mmap_malign_and_register.  */
+static int
+find_hook (grub_uint64_t start, grub_uint64_t rangesize,
+	   grub_memory_type_t memtype, void *data)
+{
+  struct grub_mmap_malign_and_register_ctx *ctx = data;
+  grub_uint64_t end = start + rangesize;
+
+  if (memtype != GRUB_MEMORY_AVAILABLE)
+    return 0;
+  if (end > 0x100000)
+    end = 0x100000;
+  if (end > start + ctx->size
+      && ctx->highestlow < ((end - ctx->size)
+			    - ((end - ctx->size) & (ctx->align - 1))))
+    ctx->highestlow = (end - ctx->size)
+		      - ((end - ctx->size) & (ctx->align - 1));
+  return 0;
+}
+
 void *
 grub_mmap_malign_and_register (grub_uint64_t align, grub_uint64_t size,
 			       int *handle, int type, int flags)
 {
-  grub_uint64_t highestlow = 0;
-
-  auto int NESTED_FUNC_ATTR find_hook (grub_uint64_t, grub_uint64_t,
-				       grub_memory_type_t);
-  int NESTED_FUNC_ATTR find_hook (grub_uint64_t start, grub_uint64_t rangesize,
-				  grub_memory_type_t memtype)
-  {
-    grub_uint64_t end = start + rangesize;
-    if (memtype != GRUB_MEMORY_AVAILABLE)
-      return 0;
-    if (end > 0x100000)
-      end = 0x100000;
-    if (end > start + size
-	&& highestlow < ((end - size) - ((end - size) & (align - 1))))
-      highestlow = (end - size)  - ((end - size) & (align - 1));
-    return 0;
-  }
+  struct grub_mmap_malign_and_register_ctx ctx = {
+    .align = align,
+    .size = size,
+    .highestlow = 0
+  };
 
   void *ret;
   if (flags & GRUB_MMAP_MALLOC_LOW)
     {
       /* FIXME: use low-memory mm allocation once it's available. */
-      grub_mmap_iterate (find_hook);
-      ret = (void *) (grub_addr_t) highestlow;
+      grub_mmap_iterate (find_hook, &ctx);
+      ret = (void *) (grub_addr_t) ctx.highestlow;
     }
   else
     ret = grub_memalign (align, size);
diff --git a/grub-core/mmap/i386/pc/mmap.c b/grub-core/mmap/i386/pc/mmap.c
index 12ae4a4..983e220 100644
--- a/grub-core/mmap/i386/pc/mmap.c
+++ b/grub-core/mmap/i386/pc/mmap.c
@@ -50,22 +50,23 @@ struct grub_e820_mmap_entry
 } __attribute__((packed));
 
 
+/* Helper for preboot.  */
+static int fill_hook (grub_uint64_t addr, grub_uint64_t size,
+		      grub_memory_type_t type, void *data)
+{
+  struct grub_e820_mmap_entry **hookmmapcur = data;
+  grub_dprintf ("mmap", "mmap chunk %llx-%llx:%x\n", addr, addr + size, type);
+  (*hookmmapcur)->addr = addr;
+  (*hookmmapcur)->len = size;
+  (*hookmmapcur)->type = type;
+  (*hookmmapcur)++;
+  return 0;
+}
+
 static grub_err_t
 preboot (int noreturn __attribute__ ((unused)))
 {
   struct grub_e820_mmap_entry *hookmmap, *hookmmapcur;
-  auto int NESTED_FUNC_ATTR fill_hook (grub_uint64_t, grub_uint64_t,
-				       grub_uint32_t);
-  int NESTED_FUNC_ATTR fill_hook (grub_uint64_t addr, grub_uint64_t size,
-				  grub_memory_type_t type)
-  {
-    grub_dprintf ("mmap", "mmap chunk %llx-%llx:%x\n", addr, addr + size, type);
-    hookmmapcur->addr = addr;
-    hookmmapcur->len = size;
-    hookmmapcur->type = type;
-    hookmmapcur++;
-    return 0;
-  }
 
   if (! hooktarget)
     return grub_error (GRUB_ERR_OUT_OF_MEMORY,
@@ -77,7 +78,7 @@ preboot (int noreturn __attribute__ ((unused)))
     ((grub_uint8_t *) hooktarget + (&grub_machine_mmaphook_end
 				    - &grub_machine_mmaphook_start));
 
-  grub_mmap_iterate (fill_hook);
+  grub_mmap_iterate (fill_hook, &hookmmapcur);
   grub_machine_mmaphook_mmap_num = hookmmapcur - hookmmap;
 
   grub_machine_mmaphook_kblow = grub_mmap_get_lower () >> 10;
@@ -123,6 +124,17 @@ preboot_rest (void)
   return GRUB_ERR_NONE;
 }
 
+/* Helper for malloc_hook.  */
+static int
+count_hook (grub_uint64_t addr __attribute__ ((unused)),
+	    grub_uint64_t size __attribute__ ((unused)),
+	    grub_memory_type_t type __attribute__ ((unused)), void *data)
+{
+  int *regcount = data;
+  (*regcount)++;
+  return 0;
+}
+
 static grub_err_t
 malloc_hook (void)
 {
@@ -131,22 +143,13 @@ malloc_hook (void)
   static int slots_available = 0;
   int hooksize;
   int regcount = 0;
-  auto int NESTED_FUNC_ATTR count_hook (grub_uint64_t, grub_uint64_t,
-					grub_uint32_t);
-  int NESTED_FUNC_ATTR count_hook (grub_uint64_t addr __attribute__ ((unused)),
-				   grub_uint64_t size __attribute__ ((unused)),
-				   grub_memory_type_t type __attribute__ ((unused)))
-  {
-    regcount++;
-    return 0;
-  }
 
   if (reentry)
     return GRUB_ERR_NONE;
 
   grub_dprintf ("mmap", "registering\n");
 
-  grub_mmap_iterate (count_hook);
+  grub_mmap_iterate (count_hook, &regcount);
 
   /* Mapping hook itself may introduce up to 2 additional regions. */
   regcount += 2;
diff --git a/grub-core/mmap/i386/uppermem.c b/grub-core/mmap/i386/uppermem.c
index 2aa4301..bd8b429 100644
--- a/grub-core/mmap/i386/uppermem.c
+++ b/grub-core/mmap/i386/uppermem.c
@@ -22,68 +22,73 @@
 #include <grub/mm.h>
 #include <grub/misc.h>
 
+/* Helper for grub_mmap_get_lower.  */
+static int
+lower_hook (grub_uint64_t addr, grub_uint64_t size, grub_memory_type_t type,
+	    void *data)
+{
+  grub_uint64_t *lower = data;
+
+  if (type != GRUB_MEMORY_AVAILABLE)
+    return 0;
+  if (addr == 0)
+    *lower = size;
+  return 0;
+}
+
 grub_uint64_t
 grub_mmap_get_lower (void)
 {
   grub_uint64_t lower = 0;
 
-  auto int NESTED_FUNC_ATTR hook (grub_uint64_t, grub_uint64_t,
-				  grub_memory_type_t);
-  int NESTED_FUNC_ATTR hook (grub_uint64_t addr, grub_uint64_t size,
-			     grub_memory_type_t type)
-    {
-      if (type != GRUB_MEMORY_AVAILABLE)
-	return 0;
-      if (addr == 0)
-	lower = size;
-      return 0;
-    }
-
-  grub_mmap_iterate (hook);
+  grub_mmap_iterate (lower_hook, &lower);
   if (lower > 0x100000)
     lower =  0x100000;
   return lower;
 }
 
+/* Helper for grub_mmap_get_upper.  */
+static int
+upper_hook (grub_uint64_t addr, grub_uint64_t size, grub_memory_type_t type,
+	    void *data)
+{
+  grub_uint64_t *upper = data;
+
+  if (type != GRUB_MEMORY_AVAILABLE)
+    return 0;
+  if (addr <= 0x100000 && addr + size > 0x100000)
+    *upper = addr + size - 0x100000;
+  return 0;
+}
+
 grub_uint64_t
 grub_mmap_get_upper (void)
 {
   grub_uint64_t upper = 0;
 
-  auto int NESTED_FUNC_ATTR hook (grub_uint64_t, grub_uint64_t,
-				  grub_memory_type_t);
-  int NESTED_FUNC_ATTR hook (grub_uint64_t addr, grub_uint64_t size,
-			     grub_memory_type_t type)
-    {
-      if (type != GRUB_MEMORY_AVAILABLE)
-	return 0;
-      if (addr <= 0x100000 && addr + size > 0x100000)
-	upper = addr + size - 0x100000;
-      return 0;
-    }
-
-  grub_mmap_iterate (hook);
+  grub_mmap_iterate (upper_hook, &upper);
   return upper;
 }
 
+/* Helper for grub_mmap_get_post64.  */
+static int
+post64_hook (grub_uint64_t addr, grub_uint64_t size, grub_memory_type_t type,
+	     void *data)
+{
+  grub_uint64_t *post64 = data;
+  if (type != GRUB_MEMORY_AVAILABLE)
+    return 0;
+  if (addr <= 0x4000000 && addr + size > 0x4000000)
+    *post64 = addr + size - 0x4000000;
+  return 0;
+}
+
 /* Count the continuous bytes after 64 MiB. */
 grub_uint64_t
 grub_mmap_get_post64 (void)
 {
   grub_uint64_t post64 = 0;
 
-  auto int NESTED_FUNC_ATTR hook (grub_uint64_t, grub_uint64_t,
-				  grub_memory_type_t);
-  int NESTED_FUNC_ATTR hook (grub_uint64_t addr, grub_uint64_t size,
-			     grub_memory_type_t type)
-    {
-      if (type != GRUB_MEMORY_AVAILABLE)
-	return 0;
-      if (addr <= 0x4000000 && addr + size > 0x4000000)
-	post64 = addr + size - 0x4000000;
-      return 0;
-    }
-
-  grub_mmap_iterate (hook);
+  grub_mmap_iterate (post64_hook, &post64);
   return post64;
 }
diff --git a/grub-core/mmap/mips/uppermem.c b/grub-core/mmap/mips/uppermem.c
index 8326185..a980e07 100644
--- a/grub-core/mmap/mips/uppermem.c
+++ b/grub-core/mmap/mips/uppermem.c
@@ -22,47 +22,51 @@
 #include <grub/misc.h>
 #include <grub/cpu/memory.h>
 
+/* Helper for grub_mmap_get_lower.  */
+static int
+lower_hook (grub_uint64_t addr, grub_uint64_t size, grub_memory_type_t type,
+	    void *data)
+{
+  grub_uint64_t *lower = data;
+
+  if (type != GRUB_MEMORY_AVAILABLE)
+    return 0;
+  if (addr == 0)
+    *lower = size;
+  return 0;
+}
+
 grub_uint64_t
 grub_mmap_get_lower (void)
 {
   grub_uint64_t lower = 0;
 
-  auto int NESTED_FUNC_ATTR hook (grub_uint64_t, grub_uint64_t,
-				  grub_memory_type_t);
-  int NESTED_FUNC_ATTR hook (grub_uint64_t addr, grub_uint64_t size,
-			     grub_memory_type_t type)
-    {
-      if (type != GRUB_MEMORY_AVAILABLE)
-	return 0;
-      if (addr == 0)
-	lower = size;
-      return 0;
-    }
-
-  grub_mmap_iterate (hook);
+  grub_mmap_iterate (lower_hook, &lower);
   if (lower > GRUB_ARCH_LOWMEMMAXSIZE)
     lower = GRUB_ARCH_LOWMEMMAXSIZE;
   return lower;
 }
 
+/* Helper for grub_mmap_get_upper.  */
+static int
+upper_hook (grub_uint64_t addr, grub_uint64_t size, grub_memory_type_t type,
+	    void *data)
+{
+  grub_uint64_t *upper = data;
+
+  if (type != GRUB_MEMORY_AVAILABLE)
+    return 0;
+  if (addr <= GRUB_ARCH_HIGHMEMPSTART && addr + size
+      > GRUB_ARCH_HIGHMEMPSTART)
+    *upper = addr + size - GRUB_ARCH_HIGHMEMPSTART;
+  return 0;
+}
+
 grub_uint64_t
 grub_mmap_get_upper (void)
 {
   grub_uint64_t upper = 0;
 
-  auto int NESTED_FUNC_ATTR hook (grub_uint64_t, grub_uint64_t,
-				  grub_memory_type_t);
-  int NESTED_FUNC_ATTR hook (grub_uint64_t addr, grub_uint64_t size,
-			     grub_memory_type_t type)
-    {
-      if (type != GRUB_MEMORY_AVAILABLE)
-	return 0;
-      if (addr <= GRUB_ARCH_HIGHMEMPSTART && addr + size
-	  > GRUB_ARCH_HIGHMEMPSTART)
-	upper = addr + size - GRUB_ARCH_HIGHMEMPSTART;
-      return 0;
-    }
-
-  grub_mmap_iterate (hook);
+  grub_mmap_iterate (upper_hook, &upper);
   return upper;
 }
diff --git a/grub-core/mmap/mmap.c b/grub-core/mmap/mmap.c
index 0b734dd..40ffb2e 100644
--- a/grub-core/mmap/mmap.c
+++ b/grub-core/mmap/mmap.c
@@ -35,43 +35,90 @@ static int curhandle = 1;
 
 #endif
 
-grub_err_t
-grub_mmap_iterate (grub_memory_hook_t hook)
+/* If same page is used by multiple types it's resolved
+   according to priority:
+   1 - free memory
+   2 - memory usable by firmware-aware code
+   3 - unusable memory
+   4 - a range deliberately empty
+*/
+static const int priority[] =
+{
+  [GRUB_MEMORY_AVAILABLE] = 1,
+  [GRUB_MEMORY_RESERVED] = 3,
+  [GRUB_MEMORY_ACPI] = 2,
+  [GRUB_MEMORY_CODE] = 3,
+  [GRUB_MEMORY_NVS] = 3,
+  [GRUB_MEMORY_HOLE] = 4,
+};
+
+/* Scanline events. */
+struct grub_mmap_scan
+{
+  /* At which memory address. */
+  grub_uint64_t pos;
+  /* 0 = region starts, 1 = region ends. */
+  int type;
+  /* Which type of memory region? */
+  int memtype;
+};
+
+/* Context for grub_mmap_iterate.  */
+struct grub_mmap_iterate_ctx
+{
+  struct grub_mmap_scan *scanline_events;
+  int i;
+};
+
+/* Helper for grub_mmap_iterate.  */
+static int
+count_hook (grub_uint64_t addr __attribute__ ((unused)),
+	    grub_uint64_t size __attribute__ ((unused)),
+	    grub_memory_type_t type __attribute__ ((unused)), void *data)
+{
+  int *mmap_num = data;
+
+  (*mmap_num)++;
+  return 0;
+}
+
+/* Helper for grub_mmap_iterate.  */
+static int
+fill_hook (grub_uint64_t addr, grub_uint64_t size, grub_memory_type_t type,
+	   void *data)
 {
+  struct grub_mmap_iterate_ctx *ctx = data;
 
+  ctx->scanline_events[ctx->i].pos = addr;
+  ctx->scanline_events[ctx->i].type = 0;
+  if (type < ARRAY_SIZE (priority) && priority[type])
+    ctx->scanline_events[ctx->i].memtype = type;
+  else
+    {
+      grub_dprintf ("mmap", "Unknown memory type %d. Assuming unusable\n",
+		    type);
+      ctx->scanline_events[ctx->i].memtype = GRUB_MEMORY_RESERVED;
+    }
+  ctx->i++;
+
+  ctx->scanline_events[ctx->i].pos = addr + size;
+  ctx->scanline_events[ctx->i].type = 1;
+  ctx->scanline_events[ctx->i].memtype =
+    ctx->scanline_events[ctx->i - 1].memtype;
+  ctx->i++;
+
+  return 0;
+}
+
+grub_err_t
+grub_mmap_iterate (grub_memory_hook_t hook, void *hook_data)
+{
   /* This function resolves overlapping regions and sorts the memory map.
      It uses scanline (sweeping) algorithm.
   */
-  /* If same page is used by multiple types it's resolved
-     according to priority:
-     1 - free memory
-     2 - memory usable by firmware-aware code
-     3 - unusable memory
-     4 - a range deliberately empty
-  */
-  int priority[] =
-    {
-      [GRUB_MEMORY_AVAILABLE] = 1,
-      [GRUB_MEMORY_RESERVED] = 3,
-      [GRUB_MEMORY_ACPI] = 2,
-      [GRUB_MEMORY_CODE] = 3,
-      [GRUB_MEMORY_NVS] = 3,
-      [GRUB_MEMORY_HOLE] = 4,
-    };
-
+  struct grub_mmap_iterate_ctx ctx;
   int i, done;
 
-  /* Scanline events. */
-  struct grub_mmap_scan
-  {
-    /* At which memory address. */
-    grub_uint64_t pos;
-    /* 0 = region starts, 1 = region ends. */
-    int type;
-    /* Which type of memory region? */
-    int memtype;
-  };
-  struct grub_mmap_scan *scanline_events;
   struct grub_mmap_scan t;
 
   /* Previous scanline event. */
@@ -88,42 +135,6 @@ grub_mmap_iterate (grub_memory_hook_t hook)
   struct grub_mmap_region *cur;
 #endif
 
-  auto int NESTED_FUNC_ATTR count_hook (grub_uint64_t, grub_uint64_t,
-					grub_uint32_t);
-  int NESTED_FUNC_ATTR count_hook (grub_uint64_t addr __attribute__ ((unused)),
-				   grub_uint64_t size __attribute__ ((unused)),
-				   grub_memory_type_t type __attribute__ ((unused)))
-  {
-    mmap_num++;
-    return 0;
-  }
-
-  auto int NESTED_FUNC_ATTR fill_hook (grub_uint64_t, grub_uint64_t,
-					grub_uint32_t);
-  int NESTED_FUNC_ATTR fill_hook (grub_uint64_t addr,
-				  grub_uint64_t size,
-				  grub_memory_type_t type)
-  {
-    scanline_events[i].pos = addr;
-    scanline_events[i].type = 0;
-    if (type < ARRAY_SIZE (priority) && priority[type])
-      scanline_events[i].memtype = type;
-    else
-      {
-	grub_dprintf ("mmap", "Unknown memory type %d. Assuming unusable\n",
-		      type);
-	scanline_events[i].memtype = GRUB_MEMORY_RESERVED;
-      }
-    i++;
-
-    scanline_events[i].pos = addr + size;
-    scanline_events[i].type = 1;
-    scanline_events[i].memtype = scanline_events[i - 1].memtype;
-    i++;
-
-    return 0;
-  }
-
   mmap_num = 0;
 
 #ifndef GRUB_MMAP_REGISTER_BY_FIRMWARE
@@ -131,37 +142,38 @@ grub_mmap_iterate (grub_memory_hook_t hook)
     mmap_num++;
 #endif
 
-  grub_machine_mmap_iterate (count_hook);
+  grub_machine_mmap_iterate (count_hook, &mmap_num);
 
   /* Initialize variables. */
   grub_memset (present, 0, sizeof (present));
-  scanline_events = (struct grub_mmap_scan *)
+  ctx.scanline_events = (struct grub_mmap_scan *)
     grub_malloc (sizeof (struct grub_mmap_scan) * 2 * mmap_num);
 
-  if (! scanline_events)
+  if (! ctx.scanline_events)
     return grub_errno;
 
-  i = 0;
+  ctx.i = 0;
 #ifndef GRUB_MMAP_REGISTER_BY_FIRMWARE
   /* Register scanline events. */
   for (cur = grub_mmap_overlays; cur; cur = cur->next)
     {
-      scanline_events[i].pos = cur->start;
-      scanline_events[i].type = 0;
+      ctx.scanline_events[ctx.i].pos = cur->start;
+      ctx.scanline_events[ctx.i].type = 0;
       if (cur->type < ARRAY_SIZE (priority) && priority[cur->type])
-	scanline_events[i].memtype = cur->type;
+	ctx.scanline_events[ctx.i].memtype = cur->type;
       else
-	scanline_events[i].memtype = GRUB_MEMORY_RESERVED;
-      i++;
-
-      scanline_events[i].pos = cur->end;
-      scanline_events[i].type = 1;
-      scanline_events[i].memtype = scanline_events[i - 1].memtype;
-      i++;
+	ctx.scanline_events[ctx.i].memtype = GRUB_MEMORY_RESERVED;
+      ctx.i++;
+
+      ctx.scanline_events[ctx.i].pos = cur->end;
+      ctx.scanline_events[ctx.i].type = 1;
+      ctx.scanline_events[ctx.i].memtype =
+	ctx.scanline_events[ctx.i - 1].memtype;
+      ctx.i++;
     }
 #endif /* ! GRUB_MMAP_REGISTER_BY_FIRMWARE */
 
-  grub_machine_mmap_iterate (fill_hook);
+  grub_machine_mmap_iterate (fill_hook, &ctx);
 
   /* Primitive bubble sort. It has complexity O(n^2) but since we're
      unlikely to have more than 100 chunks it's probably one of the
@@ -171,28 +183,28 @@ grub_mmap_iterate (grub_memory_hook_t hook)
     {
       done = 0;
       for (i = 0; i < 2 * mmap_num - 1; i++)
-	if (scanline_events[i + 1].pos < scanline_events[i].pos
-	    || (scanline_events[i + 1].pos == scanline_events[i].pos
-		&& scanline_events[i + 1].type == 0
-		&& scanline_events[i].type == 1))
+	if (ctx.scanline_events[i + 1].pos < ctx.scanline_events[i].pos
+	    || (ctx.scanline_events[i + 1].pos == ctx.scanline_events[i].pos
+		&& ctx.scanline_events[i + 1].type == 0
+		&& ctx.scanline_events[i].type == 1))
 	  {
-	    t = scanline_events[i + 1];
-	    scanline_events[i + 1] = scanline_events[i];
-	    scanline_events[i] = t;
+	    t = ctx.scanline_events[i + 1];
+	    ctx.scanline_events[i + 1] = ctx.scanline_events[i];
+	    ctx.scanline_events[i] = t;
 	    done = 1;
 	  }
     }
 
-  lastaddr = scanline_events[0].pos;
-  lasttype = scanline_events[0].memtype;
+  lastaddr = ctx.scanline_events[0].pos;
+  lasttype = ctx.scanline_events[0].memtype;
   for (i = 0; i < 2 * mmap_num; i++)
     {
       unsigned k;
       /* Process event. */
-      if (scanline_events[i].type)
-	present[scanline_events[i].memtype]--;
+      if (ctx.scanline_events[i].type)
+	present[ctx.scanline_events[i].memtype]--;
       else
-	present[scanline_events[i].memtype]++;
+	present[ctx.scanline_events[i].memtype]++;
 
       /* Determine current region type. */
       curtype = -1;
@@ -202,12 +214,13 @@ grub_mmap_iterate (grub_memory_hook_t hook)
 
       /* Announce region to the hook if necessary. */
       if ((curtype == -1 || curtype != lasttype)
-	  && lastaddr != scanline_events[i].pos
+	  && lastaddr != ctx.scanline_events[i].pos
 	  && lasttype != -1
 	  && lasttype != GRUB_MEMORY_HOLE
-	  && hook (lastaddr, scanline_events[i].pos - lastaddr, lasttype))
+	  && hook (lastaddr, ctx.scanline_events[i].pos - lastaddr, lasttype,
+		   hook_data))
 	{
-	  grub_free (scanline_events);
+	  grub_free (ctx.scanline_events);
 	  return GRUB_ERR_NONE;
 	}
 
@@ -215,11 +228,11 @@ grub_mmap_iterate (grub_memory_hook_t hook)
       if (curtype == -1 || curtype != lasttype)
 	{
 	  lasttype = curtype;
-	  lastaddr = scanline_events[i].pos;
+	  lastaddr = ctx.scanline_events[i].pos;
 	}
     }
 
-  grub_free (scanline_events);
+  grub_free (ctx.scanline_events);
   return GRUB_ERR_NONE;
 }
 
@@ -280,19 +293,23 @@ grub_mmap_unregister (int handle)
 
 #define CHUNK_SIZE	0x400
 
+struct badram_entry {
+  grub_uint64_t addr, mask;
+};
+
 static inline grub_uint64_t
-fill_mask (grub_uint64_t addr, grub_uint64_t mask, grub_uint64_t iterator)
+fill_mask (struct badram_entry *entry, grub_uint64_t iterator)
 {
   int i, j;
-  grub_uint64_t ret = (addr & mask);
+  grub_uint64_t ret = (entry->addr & entry->mask);
 
   /* Find first fixed bit. */
   for (i = 0; i < 64; i++)
-    if ((mask & (1ULL << i)) != 0)
+    if ((entry->mask & (1ULL << i)) != 0)
       break;
   j = 0;
   for (; i < 64; i++)
-    if ((mask & (1ULL << i)) == 0)
+    if ((entry->mask & (1ULL << i)) == 0)
       {
 	if ((iterator & (1ULL << j)) != 0)
 	  ret |= 1ULL << i;
@@ -301,64 +318,64 @@ fill_mask (grub_uint64_t addr, grub_uint64_t mask, grub_uint64_t iterator)
   return ret;
 }
 
+/* Helper for grub_cmd_badram.  */
+static int
+badram_iter (grub_uint64_t addr, grub_uint64_t size,
+	     grub_memory_type_t type __attribute__ ((unused)), void *data)
+{
+  struct badram_entry *entry = data;
+  grub_uint64_t iterator, low, high, cur;
+  int tail, var;
+  int i;
+  grub_dprintf ("badram", "hook %llx+%llx\n", (unsigned long long) addr,
+		(unsigned long long) size);
+
+  /* How many trailing zeros? */
+  for (tail = 0; ! (entry->mask & (1ULL << tail)); tail++);
+
+  /* How many zeros in mask? */
+  var = 0;
+  for (i = 0; i < 64; i++)
+    if (! (entry->mask & (1ULL << i)))
+      var++;
+
+  if (fill_mask (entry, 0) >= addr)
+    iterator = 0;
+  else
+    {
+      low = 0;
+      high = ~0ULL;
+      /* Find starting value. Keep low and high such that
+	 fill_mask (low) < addr and fill_mask (high) >= addr;
+      */
+      while (high - low > 1)
+	{
+	  cur = (low + high) / 2;
+	  if (fill_mask (entry, cur) >= addr)
+	    high = cur;
+	  else
+	    low = cur;
+	}
+      iterator = high;
+    }
+
+  for (; iterator < (1ULL << (var - tail))
+	 && (cur = fill_mask (entry, iterator)) < addr + size;
+       iterator++)
+    {
+      grub_dprintf ("badram", "%llx (size %llx) is a badram range\n",
+		    (unsigned long long) cur, (1ULL << tail));
+      grub_mmap_register (cur, (1ULL << tail), GRUB_MEMORY_HOLE);
+    }
+  return 0;
+}
+
 static grub_err_t
 grub_cmd_badram (grub_command_t cmd __attribute__ ((unused)),
 		 int argc, char **args)
 {
   char * str;
-  grub_uint64_t badaddr, badmask;
-
-  auto int NESTED_FUNC_ATTR hook (grub_uint64_t, grub_uint64_t,
-				 grub_memory_type_t);
-  int NESTED_FUNC_ATTR hook (grub_uint64_t addr,
-			     grub_uint64_t size,
-			     grub_memory_type_t type __attribute__ ((unused)))
-  {
-    grub_uint64_t iterator, low, high, cur;
-    int tail, var;
-    int i;
-    grub_dprintf ("badram", "hook %llx+%llx\n", (unsigned long long) addr,
-		  (unsigned long long) size);
-
-    /* How many trailing zeros? */
-    for (tail = 0; ! (badmask & (1ULL << tail)); tail++);
-
-    /* How many zeros in mask? */
-    var = 0;
-    for (i = 0; i < 64; i++)
-      if (! (badmask & (1ULL << i)))
-	var++;
-
-    if (fill_mask (badaddr, badmask, 0) >= addr)
-      iterator = 0;
-    else
-      {
-	low = 0;
-	high = ~0ULL;
-	/* Find starting value. Keep low and high such that
-	   fill_mask (low) < addr and fill_mask (high) >= addr;
-	*/
-	while (high - low > 1)
-	  {
-	    cur = (low + high) / 2;
-	    if (fill_mask (badaddr, badmask, cur) >= addr)
-	      high = cur;
-	    else
-	      low = cur;
-	  }
-	iterator = high;
-      }
-
-    for (; iterator < (1ULL << (var - tail))
-	   && (cur = fill_mask (badaddr, badmask, iterator)) < addr + size;
-	 iterator++)
-      {
-	grub_dprintf ("badram", "%llx (size %llx) is a badram range\n",
-		      (unsigned long long) cur, (1ULL << tail));
-	grub_mmap_register (cur, (1ULL << tail), GRUB_MEMORY_HOLE);
-      }
-    return 0;
-  }
+  struct badram_entry entry;
 
   if (argc != 1)
     return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("one argument expected"));
@@ -370,10 +387,10 @@ grub_cmd_badram (grub_command_t cmd __attribute__ ((unused)),
   while (1)
     {
       /* Parse address and mask.  */
-      badaddr = grub_strtoull (str, &str, 16);
+      entry.addr = grub_strtoull (str, &str, 16);
       if (*str == ',')
 	str++;
-      badmask = grub_strtoull (str, &str, 16);
+      entry.mask = grub_strtoull (str, &str, 16);
       if (*str == ',')
 	str++;
 
@@ -385,12 +402,13 @@ grub_cmd_badram (grub_command_t cmd __attribute__ ((unused)),
 
       /* When part of a page is tainted, we discard the whole of it.  There's
 	 no point in providing sub-page chunks.  */
-      badmask &= ~(CHUNK_SIZE - 1);
+      entry.mask &= ~(CHUNK_SIZE - 1);
 
       grub_dprintf ("badram", "badram %llx:%llx\n",
-		    (unsigned long long) badaddr, (unsigned long long) badmask);
+		    (unsigned long long) entry.addr,
+		    (unsigned long long) entry.mask);
 
-      grub_mmap_iterate (hook);
+      grub_mmap_iterate (badram_iter, &entry);
     }
 }
 
@@ -416,44 +434,48 @@ parsemem (const char *str)
   return ret;
 }
 
-static grub_err_t
-grub_cmd_cutmem (grub_command_t cmd __attribute__ ((unused)),
-		 int argc, char **args)
-{
+struct cutmem_range {
   grub_uint64_t from, to;
+};
 
-  auto int NESTED_FUNC_ATTR hook (grub_uint64_t, grub_uint64_t,
-				 grub_memory_type_t);
-  int NESTED_FUNC_ATTR hook (grub_uint64_t addr,
-			     grub_uint64_t size,
-			     grub_memory_type_t type __attribute__ ((unused)))
-  {
-    grub_uint64_t end = addr + size;
-
-    if (addr <= from)
-      addr = from;
-    if (end >= to)
-      end = to;
+/* Helper for grub_cmd_cutmem.  */
+static int
+cutmem_iter (grub_uint64_t addr, grub_uint64_t size,
+	     grub_memory_type_t type __attribute__ ((unused)), void *data)
+{
+  struct cutmem_range *range = data;
+  grub_uint64_t end = addr + size;
 
-    if (end <= addr)
-      return 0;
+  if (addr <= range->from)
+    addr = range->from;
+  if (end >= range->to)
+    end = range->to;
 
-    grub_mmap_register (addr, end - addr, GRUB_MEMORY_HOLE);
+  if (end <= addr)
     return 0;
-  }
+
+  grub_mmap_register (addr, end - addr, GRUB_MEMORY_HOLE);
+  return 0;
+}
+
+static grub_err_t
+grub_cmd_cutmem (grub_command_t cmd __attribute__ ((unused)),
+		 int argc, char **args)
+{
+  struct cutmem_range range;
 
   if (argc != 2)
     return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("two arguments expected"));
 
-  from = parsemem (args[0]);
+  range.from = parsemem (args[0]);
   if (grub_errno)
     return grub_errno;
 
-  to = parsemem (args[1]);
+  range.to = parsemem (args[1]);
   if (grub_errno)
     return grub_errno;
 
-  grub_mmap_iterate (hook);
+  grub_mmap_iterate (cutmem_iter, &range);
 
   return GRUB_ERR_NONE;
 }
diff --git a/include/grub/efiemu/efiemu.h b/include/grub/efiemu/efiemu.h
index 4ce3fc9..f241e75 100644
--- a/include/grub/efiemu/efiemu.h
+++ b/include/grub/efiemu/efiemu.h
@@ -226,7 +226,7 @@ grub_efiemu_finish_boot_services (grub_efi_uintn_t *memory_map_size,
 				  grub_efi_uint32_t *descriptor_version);
 
 grub_err_t
-grub_efiemu_mmap_iterate (grub_memory_hook_t hook);
+grub_efiemu_mmap_iterate (grub_memory_hook_t hook, void *hook_data);
 int grub_efiemu_sizeof_uintn_t (void);
 grub_err_t
 grub_efiemu_get_lower_upper_memory (grub_uint64_t *lower, grub_uint64_t *upper);
diff --git a/include/grub/memory.h b/include/grub/memory.h
index 61470d7..3311fcb 100644
--- a/include/grub/memory.h
+++ b/include/grub/memory.h
@@ -36,21 +36,25 @@ typedef enum grub_memory_type
     GRUB_MEMORY_HOLE = 21
   } grub_memory_type_t;
 
-typedef int NESTED_FUNC_ATTR (*grub_memory_hook_t) (grub_uint64_t,
-						    grub_uint64_t,
-						    grub_memory_type_t);
+typedef int (*grub_memory_hook_t) (grub_uint64_t,
+				   grub_uint64_t,
+				   grub_memory_type_t,
+				   void *);
 
-grub_err_t grub_mmap_iterate (grub_memory_hook_t hook);
+grub_err_t grub_mmap_iterate (grub_memory_hook_t hook, void *hook_data);
 
 #ifdef GRUB_MACHINE_EFI
 grub_err_t
-grub_efi_mmap_iterate (grub_memory_hook_t hook, int avoid_efi_boot_services);
+grub_efi_mmap_iterate (grub_memory_hook_t hook, void *hook_data,
+		       int avoid_efi_boot_services);
 #endif
 
 #if !defined (GRUB_MACHINE_EMU) && !defined (GRUB_MACHINE_EFI)
-grub_err_t EXPORT_FUNC(grub_machine_mmap_iterate) (grub_memory_hook_t hook);
+grub_err_t EXPORT_FUNC(grub_machine_mmap_iterate) (grub_memory_hook_t hook,
+						   void *hook_data);
 #else
-grub_err_t grub_machine_mmap_iterate (grub_memory_hook_t hook);
+grub_err_t grub_machine_mmap_iterate (grub_memory_hook_t hook,
+				      void *hook_data);
 #endif
 
 int grub_mmap_register (grub_uint64_t start, grub_uint64_t size, int type);
-- 
1.8.1.4

